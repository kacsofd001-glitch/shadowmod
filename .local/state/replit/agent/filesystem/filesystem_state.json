{"file_contents":{"translations.py":{"content":"\"\"\"\nMultilanguage support for the Discord bot\nSupports English (en) and Hungarian (hu)\n\"\"\"\n\nTRANSLATIONS = {\n    'en': {\n        # General\n        'bot_ready': 'Bot is ready! Logged in as {}',\n        'help_title': 'ğŸ¤– Bot Commands Help',\n        'help_description': 'Here are all available commands:',\n        'help_footer': 'Commands work with ! or / prefix! Use buttons for interactive features',\n        \n        # Tickets\n        'ticket_title': 'ğŸ« Support Tickets',\n        'ticket_description': 'Need help? Click the button below to create a ticket!',\n        'ticket_how_it_works': 'How it works:',\n        'ticket_steps': 'â€¢ Click \\'Create Ticket\\'\\nâ€¢ A private channel will be created\\nâ€¢ Our staff will assist you\\nâ€¢ Close ticket when done',\n        'ticket_button': 'ğŸ« Create Ticket',\n        'ticket_created': 'Ticket Created',\n        'ticket_created_desc': 'Your ticket has been created: {}',\n        'ticket_closed': 'Ticket Closed',\n        'ticket_closed_desc': 'This ticket has been closed.',\n        \n        # Moderation\n        'user_banned': 'ğŸ”¨ User Banned',\n        'user_banned_desc': '{} has been banned from the server.',\n        'user_kicked': 'ğŸ‘¢ User Kicked',\n        'user_kicked_desc': '{} has been kicked from the server.',\n        'user_muted': 'ğŸ”‡ User Muted',\n        'user_muted_desc': '{} has been muted.',\n        'user_unmuted': 'ğŸ”Š User Unmuted',\n        'user_unmuted_desc': '{} has been unmuted.',\n        'channel_locked': 'ğŸ”’ Channel Locked',\n        'channel_locked_desc': 'This channel has been locked.',\n        'channel_unlocked': 'ğŸ”“ Channel Unlocked',\n        'channel_unlocked_desc': 'This channel has been unlocked.',\n        'user_warned': 'âš ï¸ User Warned',\n        'user_warned_desc': '{} has been warned.',\n        'reason': 'Reason',\n        'moderator': 'Moderator',\n        'total_warnings': 'Total Warnings',\n        'no_muted_role': 'No muted role found!',\n        'user_not_muted': 'User is not muted!',\n        'ban_failed': 'Failed to ban user: {}',\n        'kick_failed': 'Failed to kick user: {}',\n        'messages_purged': 'ğŸ—‘ï¸ Messages Purged',\n        'messages_purged_desc': 'Deleted {} messages from this channel.',\n        'purge_limit': 'You can only delete up to 100 messages at once!',\n        'purge_invalid': 'Please provide a valid number of messages to delete (1-100).',\n        \n        # Fun commands\n        'magic_8ball': 'ğŸ± Magic 8-Ball',\n        'question': 'Question',\n        'answer': 'Answer',\n        'coin_flip': 'ğŸª™ Coin Flip',\n        'coin_result': '**The coin landed on: {}!**',\n        'heads': 'Heads',\n        'tails': 'Tails',\n        'meme_error': \"âŒ Couldn't fetch a meme right now!\",\n        'meme_footer': 'From r/{} | ğŸ‘ {}',\n        'meme_title': 'ğŸ˜‚ Generated Meme',\n        'generated_meme': 'Generated meme',\n        \n        # Configuration\n        'webhook_set': 'âœ… Webhook Set',\n        'webhook_set_desc': 'Bot logging webhook has been configured!',\n        'webhook_test': 'ğŸ§ª Test Webhook',\n        'webhook_test_desc': 'This is a test message from the bot!',\n        'tested_by': 'Tested by',\n        'channel': 'Channel',\n        'test_message': 'Test Message',\n        'webhook_working': 'If this appears in your webhook channel, logging is working!',\n        'webhook_configured': 'âœ… Webhook logging configured! Check your webhook channel.',\n        'test_webhook_sent': 'âœ… Test webhook sent! Check your webhook channel.',\n        'log_channel_set': 'âœ… Log Channel Set',\n        'log_channel_desc': 'Log channel has been set to {}',\n        \n        # Language\n        'language_set': 'âœ… Language Set',\n        'language_set_desc': 'Server language has been set to **{}**',\n        'language_en': 'English',\n        'language_hu': 'Hungarian',\n        'language_english': 'English',\n        'language_hungarian': 'Hungarian',\n        'current_language': 'Current language',\n        \n        # Admin/Owner Commands\n        'servers_title': 'ğŸŒ Server List',\n        'servers_description': 'I am in **{}** servers:',\n        'servers_footer': 'Total Servers: {}',\n        'invite_created': 'ğŸ”— Invite Created',\n        'invite_created_desc': 'Invite created for **{}**',\n        'invite_link': 'Invite Link',\n        'invite_expires': 'Expires',\n        'invite_never': 'Never',\n        'no_permission_invite': 'âŒ I don\\'t have permission to create invites in **{}**',\n        'server_not_found': 'âŒ Server not found! Please provide a valid server ID.',\n        'owner_only': 'âŒ This command can only be used by the bot owner!',\n        \n        # 8ball responses\n        '8ball_responses': [\n            \"It is certain.\", \"It is decidedly so.\", \"Without a doubt.\",\n            \"Yes definitely.\", \"You may rely on it.\", \"As I see it, yes.\",\n            \"Most likely.\", \"Outlook good.\", \"Yes.\", \"Signs point to yes.\",\n            \"Reply hazy, try again.\", \"Ask again later.\", \"Better not tell you now.\",\n            \"Cannot predict now.\", \"Concentrate and ask again.\",\n            \"Don't count on it.\", \"My reply is no.\", \"My sources say no.\",\n            \"Outlook not so good.\", \"Very doubtful.\"\n        ],\n        \n        # Help command\n        'help_info': 'ğŸ“Š Information',\n        'help_info_desc': '`/serverinfo` - Server statistics\\n`/botinfo` - Bot features & uptime\\n`/userinfo [@user]` - User profile with badges\\n`/support` - Support server link\\n`/webpage` - Live web dashboard',\n        'help_security': 'ğŸ” Security & Verification',\n        'help_security_desc': '`/setupverify` - Deploy verification system\\n`/setlog #channel` - Set log channel for alerts',\n        'help_antialt': 'ğŸ›¡ï¸ Anti-Alt System',\n        'help_antialt_desc': '`Auto-detects new accounts on join`\\n`/setaltage <days>` - Set min account age (default: 7d)\\nAlerts sent to log channel automatically',\n        'help_tickets': 'ğŸ« Ticket System',\n        'help_tickets_desc': '`/ticket` - Create a ticket panel\\n`/closeticket` - Close a ticket',\n        'help_moderation': 'âš”ï¸ Moderation',\n        'help_moderation_desc': '`/ban` - Ban user\\n`/kick` - Kick user\\n`/mute` `/unmute` - Mute/unmute user\\n`/tempmute <user> <time>` - Discord timeout (max 28d)\\n`/purge <1-100>` - Bulk delete messages\\n`/warn` - Warn user\\n`/lock` `/unlock` - Lock/unlock channel',\n        'help_music': 'ğŸµ Music System (YouTube â€¢ Spotify â€¢ SoundCloud)',\n        'help_music_desc': '`/play <song>` - Play music from any platform\\n`/pause` `/resume` - Pause/resume playback\\n`/skip` - Skip to next song\\n`/stop` - Stop & disconnect\\n`/queue` - Show music queue\\n`/nowplaying` - Current track info\\n`/loop` - Toggle loop mode\\n`/volume <0-100>` - Adjust volume\\n*Also supports `!` prefix for all commands*',\n        'help_games': 'ğŸ® Entertainment',\n        'help_games_desc': '`/rps` - Rock Paper Scissors\\n`/tictactoe` - Tic Tac Toe\\n`/meme` - Random meme\\n`/8ball` - Magic 8-ball\\n`/coinflip` - Flip coin\\n`/dice` - Roll dice',\n        'help_engagement': 'ğŸ Engagement',\n        'help_engagement_desc': '`/poll` - Interactive polls\\n`/giveaway` - Prize systems\\n`/ticket` - Support tickets\\n`/createrole` - Role management',\n        'help_nameauto': 'ğŸ·ï¸ Name Automation',\n        'help_nameauto_desc': '`/setprefix <@role> <prefix>` - Set role prefix\\n`/removeprefix <@role>` - Remove role prefix\\n`/viewprefixes` - View all prefixes',\n        'help_config': 'ğŸŒ System Configuration',\n        'help_config_desc': '`/setlang <en/hu>` - Language switch\\n`/setwebhook <url>` - Logging system\\n`/ping` - Latency check',\n        'help_admin': 'ğŸ‘‘ Owner Commands',\n        'help_admin_desc': '`/servers` - List all servers (name + ID)\\n`/createinvite <server_id>` - Create permanent invite\\n*Bot Owner Only*',\n        'no_reason_provided': 'No reason provided',\n        \n        # Errors\n        'error_occurred': 'âŒ An error occurred: {}',\n        'no_permission': 'âŒ You don\\'t have permission to use this command!',\n        'missing_argument': 'âŒ Missing required argument: {}',\n        'invalid_language': 'âŒ Invalid language! Use: `en` (English) or `hu` (Hungarian)',\n        'error_setting_language': 'âŒ Error setting language!',\n        'invalid_user': 'âŒ Invalid user! Please provide a valid user mention or user ID.',\n    },\n    \n    'hu': {\n        # General\n        'bot_ready': 'Bot kÃ©szen Ã¡ll! Bejelentkezve mint {}',\n        'help_title': 'ğŸ¤– Bot Parancsok SÃºgÃ³',\n        'help_description': 'Itt vannak az Ã¶sszes elÃ©rhetÅ‘ parancs:',\n        'help_footer': 'A parancsok ! vagy / elÅ‘taggal mÅ±kÃ¶dnek! HasznÃ¡lj gombokat az interaktÃ­v funkciÃ³khoz',\n        \n        # Tickets\n        'ticket_title': 'ğŸ« TÃ¡mogatÃ¡si Jegyek',\n        'ticket_description': 'SegÃ­tsÃ©gre van szÃ¼ksÃ©ged? Kattints az alÃ¡bbi gombra jegy lÃ©trehozÃ¡sÃ¡hoz!',\n        'ticket_how_it_works': 'Hogyan mÅ±kÃ¶dik:',\n        'ticket_steps': 'â€¢ Kattints a \\'Jegy LÃ©trehozÃ¡sa\\' gombra\\nâ€¢ Egy privÃ¡t csatorna jÃ¶n lÃ©tre\\nâ€¢ A szemÃ©lyzetÃ¼nk segÃ­teni fog\\nâ€¢ ZÃ¡rd le a jegyet, amikor kÃ©szen vagy',\n        'ticket_button': 'ğŸ« Jegy LÃ©trehozÃ¡sa',\n        'ticket_created': 'Jegy LÃ©trehozva',\n        'ticket_created_desc': 'A jegyed lÃ©trehozva: {}',\n        'ticket_closed': 'Jegy LezÃ¡rva',\n        'ticket_closed_desc': 'Ez a jegy le lett zÃ¡rva.',\n        \n        # Moderation\n        'user_banned': 'ğŸ”¨ FelhasznÃ¡lÃ³ Kitiltva',\n        'user_banned_desc': '{} kitiltva a szerverrÅ‘l.',\n        'user_kicked': 'ğŸ‘¢ FelhasznÃ¡lÃ³ KirÃºgva',\n        'user_kicked_desc': '{} kirÃºgva a szerverrÅ‘l.',\n        'user_muted': 'ğŸ”‡ FelhasznÃ¡lÃ³ NÃ©mÃ­tva',\n        'user_muted_desc': '{} nÃ©mÃ­tva.',\n        'user_unmuted': 'ğŸ”Š FelhasznÃ¡lÃ³ VisszahangosÃ­tva',\n        'user_unmuted_desc': '{} visszahangosÃ­tva.',\n        'channel_locked': 'ğŸ”’ Csatorna LezÃ¡rva',\n        'channel_locked_desc': 'Ez a csatorna le lett zÃ¡rva.',\n        'channel_unlocked': 'ğŸ”“ Csatorna Feloldva',\n        'channel_unlocked_desc': 'Ez a csatorna fel lett oldva.',\n        'user_warned': 'âš ï¸ FelhasznÃ¡lÃ³ Figyelmeztetve',\n        'user_warned_desc': '{} figyelmeztetÃ©st kapott.',\n        'reason': 'Indok',\n        'moderator': 'ModerÃ¡tor',\n        'total_warnings': 'Ã–sszes FigyelmeztetÃ©s',\n        'no_muted_role': 'Nincs nÃ©mÃ­tÃ¡si szerep!',\n        'user_not_muted': 'A felhasznÃ¡lÃ³ nincs nÃ©mÃ­tva!',\n        'ban_failed': 'Nem sikerÃ¼lt kitiltani a felhasznÃ¡lÃ³t: {}',\n        'kick_failed': 'Nem sikerÃ¼lt kirÃºgni a felhasznÃ¡lÃ³t: {}',\n        'messages_purged': 'ğŸ—‘ï¸ Ãœzenetek TÃ¶rÃ¶lve',\n        'messages_purged_desc': '{} Ã¼zenet tÃ¶rÃ¶lve ebbÅ‘l a csatornÃ¡bÃ³l.',\n        'purge_limit': 'Egyszerre maximum 100 Ã¼zenetet tÃ¶rÃ¶lhetsz!',\n        'purge_invalid': 'KÃ©rlek adj meg egy Ã©rvÃ©nyes szÃ¡mot (1-100).',\n        \n        # Fun commands\n        'magic_8ball': 'ğŸ± VarÃ¡zs 8-as Labda',\n        'question': 'KÃ©rdÃ©s',\n        'answer': 'VÃ¡lasz',\n        'coin_flip': 'ğŸª™ PÃ©nzfeldobÃ¡s',\n        'coin_result': '**A pÃ©nz Ã­gy esett: {}!**',\n        'heads': 'Fej',\n        'tails': 'ÃrÃ¡s',\n        'meme_error': 'âŒ Nem sikerÃ¼lt meme-et lekÃ©rni!',\n        'meme_footer': 'r/{} -bÃ³l/-bÅ‘l | ğŸ‘ {}',\n        'meme_title': 'ğŸ˜‚ GenerÃ¡lt Meme',\n        'generated_meme': 'GenerÃ¡lt meme',\n        \n        # Configuration\n        'webhook_set': 'âœ… Webhook BeÃ¡llÃ­tva',\n        'webhook_set_desc': 'A bot webhook naplÃ³zÃ¡s be lett Ã¡llÃ­tva!',\n        'webhook_test': 'ğŸ§ª Webhook Teszt',\n        'webhook_test_desc': 'Ez egy teszt Ã¼zenet a bottÃ³l!',\n        'tested_by': 'Tesztelte',\n        'channel': 'Csatorna',\n        'test_message': 'Teszt Ãœzenet',\n        'webhook_working': 'Ha ez megjelenik a webhook csatornÃ¡dban, a naplÃ³zÃ¡s mÅ±kÃ¶dik!',\n        'webhook_configured': 'âœ… Webhook naplÃ³zÃ¡s beÃ¡llÃ­tva! EllenÅ‘rizd a webhook csatornÃ¡t.',\n        'test_webhook_sent': 'âœ… Teszt webhook elkÃ¼ldve! EllenÅ‘rizd a webhook csatornÃ¡t.',\n        'log_channel_set': 'âœ… NaplÃ³ Csatorna BeÃ¡llÃ­tva',\n        'log_channel_desc': 'A naplÃ³ csatorna beÃ¡llÃ­tva: {}',\n        \n        # Language\n        'language_set': 'âœ… Nyelv BeÃ¡llÃ­tva',\n        'language_set_desc': 'A szerver nyelve beÃ¡llÃ­tva: **{}**',\n        'language_en': 'Angol',\n        'language_hu': 'Magyar',\n        'language_english': 'Angol',\n        'language_hungarian': 'Magyar',\n        'current_language': 'Jelenlegi nyelv',\n        \n        # Admin/Owner Commands\n        'servers_title': 'ğŸŒ Szerver Lista',\n        'servers_description': '**{}** szerverben vagyok:',\n        'servers_footer': 'Ã–sszes Szerver: {}',\n        'invite_created': 'ğŸ”— MeghÃ­vÃ³ LÃ©trehozva',\n        'invite_created_desc': 'MeghÃ­vÃ³ lÃ©trehozva: **{}**',\n        'invite_link': 'MeghÃ­vÃ³ Link',\n        'invite_expires': 'LejÃ¡r',\n        'invite_never': 'Soha',\n        'no_permission_invite': 'âŒ Nincs jogosultsÃ¡gom meghÃ­vÃ³ lÃ©trehozÃ¡sÃ¡ra itt: **{}**',\n        'server_not_found': 'âŒ Szerver nem talÃ¡lhatÃ³! Adj meg egy Ã©rvÃ©nyes szerver ID-t.',\n        'owner_only': 'âŒ Ezt a parancsot csak a bot tulajdonosa hasznÃ¡lhatja!',\n        \n        # 8ball responses\n        '8ball_responses': [\n            \"Biztos.\", \"HatÃ¡rozottan igen.\", \"KÃ©tsÃ©gtelenÃ¼l.\",\n            \"Igen, hatÃ¡rozottan.\", \"SzÃ¡mÃ­thatsz rÃ¡.\", \"Ãšgy lÃ¡tom, igen.\",\n            \"ValÃ³szÃ­nÅ±leg.\", \"JÃ³ a kilÃ¡tÃ¡s.\", \"Igen.\", \"A jelek igenre mutatnak.\",\n            \"HomÃ¡lyos, prÃ³bÃ¡ld Ãºjra.\", \"KÃ©rdezd kÃ©sÅ‘bb.\", \"Jobb, ha most nem mondom meg.\",\n            \"Most nem lehet megjÃ³solni.\", \"Ã–sszpontosÃ­ts Ã©s kÃ©rdezd Ãºjra.\",\n            \"Ne szÃ¡mÃ­ts rÃ¡.\", \"A vÃ¡laszom nem.\", \"A forrÃ¡saim szerint nem.\",\n            \"Nem jÃ³ a kilÃ¡tÃ¡s.\", \"Nagyon kÃ©tsÃ©ges.\"\n        ],\n        \n        # Help command\n        'help_info': 'ğŸ“Š InformÃ¡ciÃ³k',\n        'help_info_desc': '`/serverinfo` - Szerver statisztikÃ¡k\\n`/botinfo` - Bot funkciÃ³k & mÅ±kÃ¶dÃ©si idÅ‘\\n`/userinfo [@user]` - FelhasznÃ¡lÃ³ profil jelvÃ©nyekkel\\n`/support` - Support szerver link\\n`/webpage` - Ã‰lÅ‘ webes vezÃ©rlÅ‘pult',\n        'help_security': 'ğŸ” BiztonsÃ¡g & HitelesÃ­tÃ©s',\n        'help_security_desc': '`/setupverify` - HitelesÃ­tÃ©si rendszer telepÃ­tÃ©se\\n`/setlog #csatorna` - NaplÃ³ csatorna beÃ¡llÃ­tÃ¡sa',\n        'help_antialt': 'ğŸ›¡ï¸ Anti-Alt Rendszer',\n        'help_antialt_desc': '`Automatikusan Ã©szleli az Ãºj fiÃ³kokat`\\n`/setaltage <napok>` - Min. fiÃ³k kor (alapÃ©rtelmezett: 7 nap)\\nRiasztÃ¡sok automatikusan a naplÃ³ csatornÃ¡ba',\n        'help_tickets': 'ğŸ« Jegy Rendszer',\n        'help_tickets_desc': '`/ticket` - Jegy panel lÃ©trehozÃ¡sa\\n`/closeticket` - Jegy lezÃ¡rÃ¡sa',\n        'help_moderation': 'âš”ï¸ ModerÃ¡ciÃ³',\n        'help_moderation_desc': '`/ban` - FelhasznÃ¡lÃ³ kitiltÃ¡sa\\n`/kick` - FelhasznÃ¡lÃ³ kirÃºgÃ¡sa\\n`/mute` `/unmute` - NÃ©mÃ­tÃ¡s/visszahangosÃ­tÃ¡s\\n`/tempmute <user> <idÅ‘>` - Discord timeout (max 28 nap)\\n`/purge <1-100>` - TÃ¶meges Ã¼zenet tÃ¶rlÃ©s\\n`/warn` - FigyelmeztetÃ©s\\n`/lock` `/unlock` - Csatorna zÃ¡rolÃ¡s/feloldÃ¡s',\n        'help_music': 'ğŸµ Zene Rendszer (YouTube â€¢ Spotify â€¢ SoundCloud)',\n        'help_music_desc': '`/play <dal>` - Zene lejÃ¡tszÃ¡s bÃ¡rmely platformrÃ³l\\n`/pause` `/resume` - SzÃ¼neteltetÃ©s/folytatÃ¡s\\n`/skip` - KÃ¶vetkezÅ‘ dal\\n`/stop` - LeÃ¡llÃ­tÃ¡s Ã©s lecsatlakozÃ¡s\\n`/queue` - Zene vÃ¡rÃ³lista\\n`/nowplaying` - Jelenlegi dal infÃ³\\n`/loop` - IsmÃ©tlÃ©s be/ki\\n`/volume <0-100>` - HangerÅ‘ beÃ¡llÃ­tÃ¡s\\n*A `!` prefix is hasznÃ¡lhatÃ³ minden parancsnÃ¡l*',\n        'help_games': 'ğŸ® SzÃ³rakoztatÃ¡s',\n        'help_games_desc': '`/rps` - KÅ‘ PapÃ­r OllÃ³\\n`/tictactoe` - AmÅ‘ba\\n`/meme` - VÃ©letlen meme\\n`/8ball` - VarÃ¡zs labda\\n`/coinflip` - PÃ©nzfeldobÃ¡s\\n`/dice` - KockadobÃ¡s',\n        'help_engagement': 'ğŸ KÃ¶zÃ¶ssÃ©gi',\n        'help_engagement_desc': '`/poll` - InteraktÃ­v szavazÃ¡sok\\n`/giveaway` - NyeremÃ©nyjÃ¡tÃ©kok\\n`/ticket` - Support jegyek\\n`/createrole` - Szerep kezelÃ©s',\n        'help_nameauto': 'ğŸ·ï¸ NÃ©v AutomatizÃ¡lÃ¡s',\n        'help_nameauto_desc': '`/setprefix <@role> <prefix>` - Szerep prefix beÃ¡llÃ­tÃ¡sa\\n`/removeprefix <@role>` - Szerep prefix eltÃ¡volÃ­tÃ¡sa\\n`/viewprefixes` - Ã–sszes prefix megtekintÃ©se',\n        'help_config': 'ğŸŒ Rendszer KonfigurÃ¡ciÃ³',\n        'help_config_desc': '`/setlang <en/hu>` - Nyelv vÃ¡ltÃ¡s\\n`/setwebhook <url>` - NaplÃ³zÃ³ rendszer\\n`/ping` - KÃ©sleltetÃ©s ellenÅ‘rzÃ©s',\n        'help_admin': 'ğŸ‘‘ Tulajdonos Parancsok',\n        'help_admin_desc': '`/servers` - Ã–sszes szerver listÃ¡zÃ¡sa (nÃ©v + ID)\\n`/createinvite <server_id>` - VÃ©gleges meghÃ­vÃ³ lÃ©trehozÃ¡sa\\n*Csak Bot Tulajdonosnak*',\n        'no_reason_provided': 'Nincs megadva indok',\n        \n        # Errors\n        'error_occurred': 'âŒ Hiba tÃ¶rtÃ©nt: {}',\n        'no_permission': 'âŒ Nincs jogosultsÃ¡god ehhez a parancshoz!',\n        'missing_argument': 'âŒ HiÃ¡nyzÃ³ kÃ¶telezÅ‘ paramÃ©ter: {}',\n        'invalid_language': 'âŒ Ã‰rvÃ©nytelen nyelv! HasznÃ¡ld: `en` (English) vagy `hu` (Hungarian)',\n        'error_setting_language': 'âŒ Hiba a nyelv beÃ¡llÃ­tÃ¡sakor!',\n        'invalid_user': 'âŒ Ã‰rvÃ©nytelen felhasznÃ¡lÃ³! Adj meg egy Ã©rvÃ©nyes mention-t vagy felhasznÃ¡lÃ³ ID-t.',\n    }\n}\n\ndef get_text(guild_id, key, *args, **kwargs):\n    \"\"\"\n    Get translated text for a guild\n    \n    Args:\n        guild_id: Discord guild ID\n        key: Translation key\n        *args: Format arguments\n        **kwargs: Additional options (lang override)\n    \n    Returns:\n        Translated and formatted string\n    \"\"\"\n    import config\n    \n    cfg = config.load_config()\n    guild_langs = cfg.get('guild_languages', {})\n    lang = kwargs.get('lang') or guild_langs.get(str(guild_id), 'en')\n    \n    # Fallback to English if language not found\n    if lang not in TRANSLATIONS:\n        lang = 'en'\n    \n    # Get translation, fallback to English if key not found\n    text = TRANSLATIONS[lang].get(key)\n    if text is None:\n        text = TRANSLATIONS['en'].get(key, key)\n    \n    # Format with arguments if provided\n    if args:\n        try:\n            return text.format(*args)\n        except:\n            return text\n    \n    return text\n\ndef get_guild_language(guild_id):\n    \"\"\"Get the current language for a guild\"\"\"\n    import config\n    \n    cfg = config.load_config()\n    guild_langs = cfg.get('guild_languages', {})\n    return guild_langs.get(str(guild_id), 'en')\n\ndef set_guild_language(guild_id, lang):\n    \"\"\"Set the language for a guild\"\"\"\n    import config\n    \n    if lang not in TRANSLATIONS:\n        return False\n    \n    cfg = config.load_config()\n    if 'guild_languages' not in cfg:\n        cfg['guild_languages'] = {}\n    \n    cfg['guild_languages'][str(guild_id)] = lang\n    config.save_config(cfg)\n    return True\n","size_bytes":18815},"cogs/nameauto.py":{"content":"import discord\nfrom discord.ext import commands\nimport config\n\nclass NameAutomation(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    def get_prefix_for_member(self, member):\n        cfg = config.load_config()\n        role_prefixes = cfg.get('role_prefixes', {})\n        \n        for role in sorted(member.roles, key=lambda r: r.position, reverse=True):\n            role_id = str(role.id)\n            if role_id in role_prefixes:\n                return role_prefixes[role_id]\n        \n        return None\n    \n    async def update_member_nickname(self, member):\n        if member.bot:\n            return\n        \n        try:\n            cfg = config.load_config()\n            role_prefixes = cfg.get('role_prefixes', {})\n            all_prefixes = list(set(role_prefixes.values()))\n            \n            prefix = self.get_prefix_for_member(member)\n            \n            current_nick = member.display_name\n            \n            # Remove all existing prefixes from the nickname\n            changed = True\n            while changed:\n                changed = False\n                for p in all_prefixes:\n                    prefix_with_space = f\"{p} \"\n                    if current_nick.startswith(prefix_with_space):\n                        current_nick = current_nick[len(prefix_with_space):]\n                        changed = True\n                        break\n            \n            # Remove any leading/trailing whitespace\n            current_nick = current_nick.strip()\n            \n            if prefix:\n                new_nick = f\"{prefix} {current_nick}\"\n            else:\n                new_nick = current_nick\n            \n            # Limit to 32 characters (Discord's nickname limit)\n            new_nick = new_nick[:32]\n            \n            # Only update if the nickname actually changed\n            if member.nick != new_nick:\n                await member.edit(nick=new_nick)\n        except discord.Forbidden:\n            pass\n        except Exception:\n            pass\n    \n    @commands.Cog.listener()\n    async def on_member_join(self, member):\n        await self.update_member_nickname(member)\n    \n    @commands.Cog.listener()\n    async def on_member_update(self, before, after):\n        if before.roles != after.roles:\n            await self.update_member_nickname(after)\n    \n    @commands.command(name='setprefix')\n    @commands.has_permissions(administrator=True)\n    async def set_role_prefix(self, ctx, role: discord.Role, prefix: str):\n        if len(prefix) > 10:\n            await ctx.send(\"âŒ Prefix must be 10 characters or less!\")\n            return\n        \n        cfg = config.load_config()\n        if 'role_prefixes' not in cfg:\n            cfg['role_prefixes'] = {}\n        \n        old_prefix = cfg['role_prefixes'].get(str(role.id))\n        cfg['role_prefixes'][str(role.id)] = prefix\n        config.save_config(cfg)\n        \n        embed = discord.Embed(\n            title=\"âœ… Prefix Set\",\n            description=f\"Members with {role.mention} will have `{prefix}` prefix in their nickname!\",\n            color=0x00F3FF\n        )\n        embed.add_field(name=\"Example\", value=f\"{prefix} Username\", inline=False)\n        \n        msg = await ctx.send(embed=embed)\n        \n        await msg.edit(content=\"ğŸ”„ Updating member nicknames...\", embed=embed)\n        count = 0\n        for member in ctx.guild.members:\n            if role in member.roles:\n                await self.update_member_nickname(member)\n                count += 1\n        \n        embed.add_field(name=\"Updated\", value=f\"{count} members updated!\", inline=False)\n        await msg.edit(content=None, embed=embed)\n    \n    @commands.command(name='removeprefix')\n    @commands.has_permissions(administrator=True)\n    async def remove_role_prefix(self, ctx, role: discord.Role):\n        cfg = config.load_config()\n        role_prefixes = cfg.get('role_prefixes', {})\n        \n        if str(role.id) not in role_prefixes:\n            await ctx.send(f\"âŒ {role.mention} doesn't have a prefix set!\")\n            return\n        \n        del cfg['role_prefixes'][str(role.id)]\n        config.save_config(cfg)\n        \n        embed = discord.Embed(\n            title=\"âœ… Prefix Removed\",\n            description=f\"Prefix removed from {role.mention}\",\n            color=0x00F3FF\n        )\n        \n        msg = await ctx.send(embed=embed)\n        \n        await msg.edit(content=\"ğŸ”„ Updating member nicknames...\", embed=embed)\n        count = 0\n        for member in ctx.guild.members:\n            if role in member.roles:\n                await self.update_member_nickname(member)\n                count += 1\n        \n        embed.add_field(name=\"Updated\", value=f\"{count} members updated!\", inline=False)\n        await msg.edit(content=None, embed=embed)\n    \n    @commands.command(name='updateallnicks')\n    @commands.has_permissions(administrator=True)\n    async def update_all_nicknames(self, ctx):\n        await ctx.send(\"ğŸ”„ Updating all member nicknames... This may take a while.\")\n        \n        count = 0\n        for member in ctx.guild.members:\n            await self.update_member_nickname(member)\n            count += 1\n        \n        embed = discord.Embed(\n            title=\"âœ… Nicknames Updated\",\n            description=f\"Updated nicknames for {count} members!\",\n            color=0x00F3FF\n        )\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='viewprefixes')\n    async def view_prefixes(self, ctx):\n        cfg = config.load_config()\n        role_prefixes = cfg.get('role_prefixes', {})\n        \n        if not role_prefixes:\n            await ctx.send(\"âŒ No role prefixes configured!\")\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ“‹ Role Prefixes\",\n            description=\"Current role prefix configuration:\",\n            color=0x8B00FF\n        )\n        \n        for role_id, prefix in role_prefixes.items():\n            role = ctx.guild.get_role(int(role_id))\n            if role:\n                embed.add_field(\n                    name=role.name,\n                    value=f\"Prefix: `{prefix}`\",\n                    inline=False\n                )\n        \n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(NameAutomation(bot))\n","size_bytes":6312},"cogs/antialt.py":{"content":"import discord\nfrom discord.ext import commands\nfrom datetime import datetime, timedelta, timezone\nimport config\n\nclass AntiAlt(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.Cog.listener()\n    async def on_member_join(self, member):\n        cfg = config.load_config()\n        min_age_days = cfg.get('min_account_age_days', 7)\n        \n        account_age = datetime.now(timezone.utc) - member.created_at\n        age_in_days = account_age.days\n        \n        if age_in_days < min_age_days:\n            try:\n                welcome_embed = discord.Embed(\n                    title=\"âš ï¸ Account Age Warning\",\n                    description=f\"Your account is only {age_in_days} days old. Please be aware that you may have limited permissions until your account ages.\",\n                    color=0xFF006E\n                )\n                await member.send(embed=welcome_embed)\n            except:\n                pass\n    \n    @commands.command(name='setaltage')\n    @commands.has_permissions(administrator=True)\n    async def set_alt_age(self, ctx, days: int):\n        if days < 0:\n            await ctx.send(\"âŒ Days must be a positive number!\")\n            return\n        \n        config.update_config('min_account_age_days', days)\n        \n        embed = discord.Embed(\n            title=\"âœ… Anti-Alt Configuration Updated\",\n            description=f\"Minimum account age set to **{days} days**\",\n            color=0x00F3FF\n        )\n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(AntiAlt(bot))\n","size_bytes":1577},"cogs/logging.py":{"content":"import discord\nfrom discord.ext import commands\nfrom datetime import datetime, timezone\nimport config\n\nclass Logging(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    async def send_log(self, embed):\n        cfg = config.load_config()\n        log_channel_id = cfg.get('log_channel_id')\n        \n        if log_channel_id:\n            log_channel = self.bot.get_channel(log_channel_id)\n            if log_channel:\n                await log_channel.send(embed=embed)\n    \n    @commands.Cog.listener()\n    async def on_message_delete(self, message):\n        if message.author.bot:\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ—‘ï¸ Message Deleted\",\n            description=f\"**Author:** {message.author.mention}\\n**Channel:** {message.channel.mention}\",\n            color=0xFF006E,\n            timestamp=datetime.now(timezone.utc)\n        )\n        embed.add_field(\n            name=\"Content\",\n            value=message.content[:1024] if message.content else \"*No content*\",\n            inline=False\n        )\n        embed.set_footer(text=f\"User ID: {message.author.id}\")\n        \n        await self.send_log(embed)\n    \n    @commands.Cog.listener()\n    async def on_message_edit(self, before, after):\n        if before.author.bot or before.content == after.content:\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ“ Message Edited\",\n            description=f\"**Author:** {before.author.mention}\\n**Channel:** {before.channel.mention}\",\n            color=0xFF006E,\n            timestamp=datetime.now(timezone.utc)\n        )\n        embed.add_field(\n            name=\"Before\",\n            value=before.content[:512] if before.content else \"*No content*\",\n            inline=False\n        )\n        embed.add_field(\n            name=\"After\",\n            value=after.content[:512] if after.content else \"*No content*\",\n            inline=False\n        )\n        embed.set_footer(text=f\"User ID: {before.author.id}\")\n        \n        await self.send_log(embed)\n    \n    @commands.Cog.listener()\n    async def on_member_join(self, member):\n        cfg = config.load_config()\n        min_age_days = cfg.get('min_account_age_days', 7)\n        \n        account_age = datetime.now(timezone.utc) - member.created_at\n        age_in_days = account_age.days\n        \n        is_alt = age_in_days < min_age_days\n        \n        embed = discord.Embed(\n            title=\"ğŸš¨ Possible Alt Account Detected - Member Joined\" if is_alt else \"ğŸ“¥ Member Joined\",\n            description=f\"**User:** {member.mention} ({member})\",\n            color=0xFF006E if is_alt else 0x00F3FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        embed.add_field(\n            name=\"Account Created\",\n            value=f\"{member.created_at.strftime('%Y-%m-%d %H:%M:%S')} UTC\",\n            inline=True\n        )\n        embed.add_field(\n            name=\"Account Age\",\n            value=f\"{age_in_days} days old\" + (f\" âš ï¸ (Required: {min_age_days}+ days)\" if is_alt else \"\"),\n            inline=True\n        )\n        embed.set_thumbnail(url=member.display_avatar.url)\n        embed.set_footer(text=f\"User ID: {member.id} | Total Members: {member.guild.member_count}\")\n        \n        await self.send_log(embed)\n    \n    @commands.Cog.listener()\n    async def on_member_remove(self, member):\n        embed = discord.Embed(\n            title=\"ğŸ“¤ Member Left\",\n            description=f\"**User:** {member.mention} ({member})\",\n            color=0xFF006E,\n            timestamp=datetime.now(timezone.utc)\n        )\n        embed.set_thumbnail(url=member.display_avatar.url)\n        embed.set_footer(text=f\"User ID: {member.id} | Total Members: {member.guild.member_count}\")\n        \n        await self.send_log(embed)\n    \n    @commands.Cog.listener()\n    async def on_member_ban(self, guild, user):\n        embed = discord.Embed(\n            title=\"ğŸ”¨ Member Banned\",\n            description=f\"**User:** {user.mention} ({user})\",\n            color=discord.Color.dark_red(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        embed.set_thumbnail(url=user.display_avatar.url)\n        embed.set_footer(text=f\"User ID: {user.id}\")\n        \n        await self.send_log(embed)\n    \n    @commands.command(name='setlog')\n    @commands.has_permissions(administrator=True)\n    async def set_log_channel(self, ctx, channel: discord.TextChannel):\n        config.update_config('log_channel_id', channel.id)\n        \n        embed = discord.Embed(\n            title=\"âœ… Log Channel Set\",\n            description=f\"Log channel has been set to {channel.mention}\",\n            color=0x00F3FF\n        )\n        await ctx.send(embed=embed)\n        \n        welcome_embed = discord.Embed(\n            title=\"ğŸ“‹ Logging System Activated\",\n            description=\"This channel will now receive all bot logs including:\\nâ€¢ Message deletions and edits\\nâ€¢ Member joins and leaves\\nâ€¢ Bans and kicks\\nâ€¢ Anti-alt detections\\nâ€¢ Moderation actions\",\n            color=0x8B00FF\n        )\n        await channel.send(embed=welcome_embed)\n\nasync def setup(bot):\n    await bot.add_cog(Logging(bot))\n","size_bytes":5175},"README.md":{"content":"# ğŸ¤– Discord Bot with Buttons & Embeds\n\nA feature-rich Discord bot built with Python and discord.py featuring an automated ticket system, anti-alt detection, comprehensive logging, moderation tools, interactive games, and fun commands!\n\n## âœ¨ Features\n\n### ğŸŒ Multilanguage Support\n- **English** and **Hungarian** language support\n- Set server language with `/setlang` or `!setlang`\n- All commands and messages automatically adapt to selected language\n- Per-server language preferences saved automatically\n\n### ğŸ« Ticket System\n- Button-based ticket creation\n- Automatic ticket channels with proper permissions\n- Easy ticket closing with confirmation embeds\n\n### ğŸ›¡ï¸ Anti-Alt Detection\n- **Automatically detects new/alt accounts** based on account age\n- **Configurable minimum account age threshold** (default: 7 days)\n- **Logs suspicious joins** to your designated log channel with detailed info\n- **DM warnings** sent to new accounts (if DMs are open)\n- **Configure with:** `!setaltage <days>` (Admin only)\n- Example: `!setaltage 14` - Set minimum account age to 14 days\n- The system checks every new member join and alerts if account is younger than threshold\n\n### ğŸ“‹ Logging System\n- Logs all important events to a Discord channel\n- Message deletions and edits\n- Member joins and leaves\n- Bans, kicks, and moderation actions\n- **Webhook Logging** - Real-time bot error and event logging to Discord via webhooks\n- Monitor bot health, command errors, and system events through Discord embeds\n- No need to check bot code!\n\n### ğŸ”¨ Moderation Commands\n- `!ban` - Ban users\n- `!kick` - Kick users\n- `!mute` / `!unmute` - Mute/unmute users\n- `!tempmute` - Temporary mute with automatic unmute\n- `!tempban` - Temporary ban with automatic unban\n- `!lock` / `!unlock` - Lock/unlock channels\n- `!warn` - Warn users\n- `!warnings` - Check user warnings\n\n### ğŸ® Interactive Games\n- **Rock Paper Scissors** - Play against the bot with button controls\n- **Tic Tac Toe** - Challenge another user to a game with interactive board\n\n### ğŸ˜„ Fun Commands\n- `!meme` - Generate random memes\n- `!sound` - Random sound effects\n- `!8ball` - Ask the magic 8-ball\n- `!coinflip` - Flip a coin\n- `!roll` - Roll dice (e.g., `!roll 2d6`)\n\n### ğŸ“Š Poll System\n- **Interactive Polls** - Create polls with button voting\n- **Quick Polls** - Fast yes/no/maybe polls with reactions\n- **Live Results** - Real-time vote counting with progress bars\n\n### ğŸ‘¥ Role Management\n- Create and delete roles with custom colors\n- Assign/remove roles from members\n- View role information and member counts\n- List all server roles\n\n### ğŸ‰ Giveaway System\n- Create timed giveaways with automatic winner selection\n- Button-based entry system\n- Multiple winner support\n- Automatic ending and winner announcement\n- Reroll functionality\n\n### ğŸ“ Name Automation\n- Automatically add role prefixes to member nicknames\n- Configure custom prefixes for different roles (e.g., \"M |\" for members, \"A |\" for admins)\n- Automatic nickname updates on join and role changes\n- Bulk nickname update commands\n\n### â„¹ï¸ Information Commands\n- **Server Info** - Comprehensive server statistics and information\n- **Bot Info** - Bot features, statistics, and uptime\n- **User Info** - Detailed user profiles with badges (Staff, Partner, HypeSquad, Bug Hunter, Early Supporter, Active Developer, etc.)\n- **Support Server** - Quick access to the support server invite\n- **Web Dashboard** - Link to the live statistics web page\n\n### ğŸŒ Live Web Dashboard\n- **Real-time statistics** displayed on a public web page\n- **Futuristic cyberpunk theme** with neon colors and animated starfield\n- **Auto-refreshing data** every 5 seconds\n- Shows server count, user count, channel count, and uptime\n- **Accessible at:** `https://shadowmod.net/dashboard` (root path auto-redirects)\n- Use `/webpage` command in Discord to get the direct link\n\n## ğŸš€ Setup Instructions\n\n### 1. Get Your Discord Bot Token\n\n1. Go to [Discord Developer Portal](https://discord.com/developers/applications)\n2. Click \"New Application\" and give it a name\n3. Go to the \"Bot\" section\n4. Click \"Add Bot\"\n5. Under the bot's username, click \"Reset Token\" and copy it\n6. Enable these Privileged Gateway Intents:\n   - Presence Intent\n   - Server Members Intent\n   - Message Content Intent\n\n### 2. Set Up Your Bot Token\n\nCreate a `.env` file in the project root and add:\n```\nDISCORD_TOKEN=your_bot_token_here\n```\n\n### 3. Invite the Bot to Your Server\n\n1. Go to OAuth2 > URL Generator in the Discord Developer Portal\n2. Select scopes: `bot` and `applications.commands`\n3. Select bot permissions:\n   - Administrator (or specific permissions you want)\n4. Copy the generated URL and open it in your browser\n5. Select your server and authorize\n\n### 4. Run the Bot\n\nThe bot will start automatically on Replit. If you need to run it manually:\n```bash\npython main.py\n```\n\n## ğŸ“– Command Guide\n\n**Note:** All key commands support both `!` prefix and `/` slash commands for Discord's Active Developer badge!\n\n### Help Command\nBoth `!help` and `/help` now include all 28 slash commands organized by category:\n- **ğŸ“Š INFORMATION SYSTEMS** - `/serverinfo`, `/botinfo`, `/userinfo`, `/support`, `/webpage`\n- **ğŸ” SECURITY & VERIFICATION** - `/setupverify`, `/setlog`\n- **ğŸ›¡ï¸ ANTI-ALT SYSTEM** - Auto-detects new accounts, `/setaltage`\n- **âš”ï¸ MODERATION MATRIX** - `/ban`, `/kick`, `/mute`, `/unmute`, `/tempmute`, `/purge`, `/warn`, `/lock`, `/unlock`\n- **ğŸ§  AI NEURAL LINK** - @mention the bot anywhere for AI chat\n- **ğŸ® ENTERTAINMENT SYSTEMS** - `/rps`, `/tictactoe`, `/meme`, `/8ball`, `/coinflip`, `/dice`\n- **ğŸ ENGAGEMENT PROTOCOLS** - `/poll`, `/giveaway`, `/ticket`, `/createrole`\n- **ğŸ·ï¸ NAME AUTOMATION** - `/setprefix`, `/removeprefix`, `/viewprefixes`\n- **ğŸŒ SYSTEM CONFIGURATION** - `/setlang`, `/setwebhook`, `/ping`\n\n### Setup Commands (Admin Only)\n- `!setlog #channel` or `/setlog` - Set the channel for bot logs\n- `!setaltage <days>` - Set minimum account age (default: 7 days)\n- `!setwebhook <url>` or `/setwebhook` - Set webhook URL for bot error logging\n- `!testwebhook` or `/testwebhook` - Test the webhook logging system\n- `!ticket` or `/ticket` - Create a ticket panel with button\n- `!setlang <en/hu>` or `/setlang` - Change server language (English/Hungarian)\n\n### Moderation Commands\n**All moderation slash commands accept both user mentions (@user) and user IDs!**\n```\n!ban @user [reason]   or  /ban <@user or ID>     - Ban a user\n!kick @user [reason]  or  /kick <@user or ID>    - Kick a user\n!mute @user           or  /mute <@user or ID>    - Mute a user (role-based)\n!unmute @user         or  /unmute <@user or ID>  - Unmute a user\n!tempmute @user 10m                              - Discord timeout (10s-28d) â±ï¸\n!tempban @user 1d reason                         - Temporarily ban\n!lock                 or  /lock                  - Lock current channel\n!unlock               or  /unlock                - Unlock current channel\n!warn @user [reason]  or  /warn <@user or ID>    - Warn a user\n!warnings @user                                  - Check user's warnings\n!purge <amount>       or  /purge <amount>        - Delete 1-100 messages ğŸ—‘ï¸\n```\n\n**Note:** `!tempmute` now uses Discord's native timeout feature! This prevents the user from sending messages, reacting, joining voice channels, and more. Maximum duration is 28 days. Discord automatically removes the timeout when it expires.\n\n### Game Commands\n```\n!rps                - Play Rock Paper Scissors\n!tictactoe @user    - Play Tic Tac Toe with another user\n```\n\n### Fun Commands\n```\n!meme              or  /meme      - Generate a language-aware meme ğŸŒ\n!sound                            - Random sound effect\n!8ball <question>  or  /8ball     - Ask the magic 8-ball\n!coinflip          or  /coinflip  - Flip a coin\n!roll 2d6                         - Roll dice\n```\n**ğŸŒ Meme Generator:** Automatically generates memes in **English** or **Hungarian** based on your server language!\n\n### Poll Commands\n```\n!poll <question> <opt1> <opt2> ...  - Create interactive poll with buttons\n!quickpoll <question>               - Create yes/no/maybe poll with reactions\n```\n\n### Role Commands\n```\n!addrole @user @role       - Add a role to a user\n!removerole @user @role    - Remove a role from a user\n!createrole <name> [color] - Create a new role (color in hex: #FF5733)\n!deleterole @role          - Delete a role\n!roleinfo @role            - View detailed role information\n!roles                     - List all server roles\n```\n\n### Giveaway Commands\n```\n!giveaway <time> <winners> <prize>  - Start a giveaway (e.g., !giveaway 1d 2 Nitro)\n!reroll <message_id>                - Reroll a giveaway winner\n```\n\n### Name Automation Commands\n```\n!setprefix @role <prefix>  or  /setprefix <@role> <prefix>  - Set automatic name prefix for role\n!removeprefix @role        or  /removeprefix <@role>        - Remove prefix from a role\n!viewprefixes              or  /viewprefixes                - View all configured role prefixes\n!updateallnicks                                             - Manually update all member nicknames\n```\n**Note:** When you set or remove a role prefix, all members with that role are automatically updated!\n\n### AI Chat ğŸ¤–\n**Simply mention the bot anywhere** to get AI-powered responses!\n\n```\n@YourBot hello!\n@YourBot what's 2+2?\n@YourBot tell me a joke\n```\n\nThe bot will respond in your server's language (English or Hungarian based on `/setlang`). Works in any channel!\n\n### Verification System (NEW! ğŸ”)\n```\n/setupverify <#channel> <@roles_to_add> <@roles_to_remove>  - Setup member verification\n```\n**Admin only.** Creates a verification panel with a button. Members must pass anti-alt check (account age) to verify. Automatically adds/removes configured roles!\n\n### Information Commands\n```\n!serverinfo  or  /serverinfo  - Show detailed server information and statistics\n!botinfo     or  /botinfo     - Display bot features, stats, and uptime\n!userinfo [@user]  or  /userinfo [@user]  - Show user profile with badges\n!support     or  /support     - Get the support server invite link\n!webpage     or  /webpage     - Get the live web dashboard link\n```\n\n### General\n```\n!help  or  /help   - Show all commands\n!ping  or  /ping   - Check bot latency (for Active Developer Badge!)\n```\n\n## ğŸ¨ All Features Use Embeds & Buttons!\n\nEvery interaction with this bot uses Discord's modern UI features:\n- âœ… Beautiful embed messages with colors and formatting\n- âœ… Interactive buttons for games and actions\n- âœ… Persistent button views for ticket creation\n- âœ… User-friendly and visually appealing\n\n## ğŸ“ Configuration\n\nThe bot stores configuration in `bot_config.json` including:\n- Log channel ID\n- Ticket counter\n- Muted role IDs (per guild)\n- Minimum account age for alt detection\n- User warnings\n- Temporary bans and mutes\n- Active giveaways\n- Role name prefixes\n\n### Setting Up Webhook Logging\n\nTo monitor your bot's health and errors in real-time via Discord:\n\n1. **Create a Webhook in Discord:**\n   - Right-click the channel where you want bot logs\n   - Click \"Edit Channel\" â†’ \"Integrations\" â†’ \"Webhooks\"\n   - Click \"New Webhook\" or \"Create Webhook\"\n   - Copy the webhook URL\n\n2. **Set the Webhook in Your Bot:**\n   ```\n   !setwebhook https://discord.com/api/webhooks/YOUR_WEBHOOK_URL\n   ```\n\n3. **Test It:**\n   ```\n   !testwebhook\n   ```\n\nNow you'll receive:\n- âœ… Bot startup notifications\n- âš ï¸ Command errors with details\n- âŒ Critical bot errors with stack traces\n- â„¹ï¸ Custom info logs\n\n## ğŸ”§ Troubleshooting\n\n**Bot doesn't respond:**\n- Make sure the bot has proper permissions\n- Check if Message Content Intent is enabled\n- Verify the bot token is correct in `.env`\n\n**Temp mute/ban not working:**\n- The bot needs to stay online for temporary actions to expire\n- Check the bot's role is higher than the muted role\n\n**Tickets not creating:**\n- Ensure the bot has \"Manage Channels\" permission\n- The bot's role must be higher than @everyone\n\n## ğŸ“¦ Dependencies\n\n- discord.py - Discord API wrapper\n- python-dotenv - Environment variable management\n- aiohttp - Async HTTP requests for meme API\n- Pillow - Image processing\n\n## ğŸ‰ Enjoy!\n\nYour Discord bot is now ready with all features working through beautiful embeds and interactive buttons!\n","size_bytes":12300},"main.py":{"content":"import discord\nfrom discord.ext import commands\nimport asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom datetime import datetime, timezone\nimport json\nimport config\n\nload_dotenv()\n\nintents = discord.Intents.all()\n\n# Shared stats file for web server\nSTATS_FILE = 'bot_stats.json'\n\ndef get_prefix(bot, message):\n    \"\"\"Dynamic prefix per guild\"\"\"\n    if message.guild:\n        return config.get_guild_prefix(message.guild.id)\n    return '!'\n\nclass DiscordBot(commands.Bot):\n    def __init__(self):\n        super().__init__(\n            command_prefix=get_prefix,\n            intents=intents,\n            help_command=None\n        )\n        self.start_time = datetime.now(timezone.utc)\n        \n    async def setup_hook(self):\n        await self.load_extension('cogs.tickets')\n        await self.load_extension('cogs.antialt')\n        await self.load_extension('cogs.logging')\n        await self.load_extension('cogs.moderation')\n        await self.load_extension('cogs.games')\n        await self.load_extension('cogs.fun')\n        await self.load_extension('cogs.polls')\n        await self.load_extension('cogs.roles')\n        await self.load_extension('cogs.giveaways')\n        await self.load_extension('cogs.nameauto')\n        await self.load_extension('cogs.webhook_logging')\n        await self.load_extension('cogs.language')\n        await self.load_extension('cogs.aichat')\n        await self.load_extension('cogs.verify')\n        await self.load_extension('cogs.info')\n        await self.load_extension('cogs.music')\n        await self.load_extension('cogs.admin')\n        await self.load_extension('cogs.customcommands')\n        await self.load_extension('cogs.slash_commands')\n        print(\"All cogs loaded successfully!\")\n        \n    async def on_ready(self):\n        print(f'Bot is ready! Logged in as {self.user}')\n        print(f'Bot ID: {self.user.id}')\n        print('------')\n        \n        try:\n            synced = await self.tree.sync()\n            print(f'Synced {len(synced)} slash commands')\n        except Exception as e:\n            print(f'Failed to sync commands: {e}')\n        \n        await self.change_presence(\n            activity=discord.Activity(\n                type=discord.ActivityType.watching,\n                name=\"ğŸŒ /help | Futuristic Bot\"\n            )\n        )\n        \n        # Update stats file for web server\n        self.update_stats_file()\n    \n    def update_stats_file(self):\n        \"\"\"Update bot stats for web server\"\"\"\n        total_members = sum(guild.member_count or 0 for guild in self.guilds)\n        total_channels = sum(len(guild.channels) for guild in self.guilds)\n        \n        stats = {\n            'start_time': self.start_time.isoformat(),\n            'guilds': len(self.guilds),\n            'users': total_members,\n            'channels': total_channels,\n            'status': 'online'\n        }\n        \n        try:\n            with open(STATS_FILE, 'w') as f:\n                json.dump(stats, f)\n        except:\n            pass\n\nbot = DiscordBot()\n\n@bot.command(name='help')\nasync def help_command(ctx):\n    # Get current prefix for this server\n    prefix = config.get_guild_prefix(ctx.guild.id) if ctx.guild else '!'\n    \n    embed = discord.Embed(\n        title=\"âš¡ SHADOW-MOD âœ¨ | COMMAND DATABASE\",\n        description=f\"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`Next-Gen Discord Moderation System`\\n**Current Prefix:** `{prefix}` | **Slash:** `/`\\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\",\n        color=0x00F3FF  # Neon cyan\n    )\n    \n    embed.add_field(\n        name=\"ğŸ“Š INFORMATION SYSTEMS\",\n        value=\"`/serverinfo` - Server statistics & details\\n`/botinfo` - Bot features & uptime\\n`/userinfo [@user]` - User profile with badges\\n`/support` - Support server link\\n`/webpage` - Live web dashboard\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸ” SECURITY & VERIFICATION\",\n        value=\"`/setupverify` - Deploy verification system\\n`/setlog #channel` - Set log channel for alerts\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸ›¡ï¸ ANTI-ALT SYSTEM\",\n        value=\"`Auto-detects new accounts on join`\\n`/setaltage <days>` - Set min account age (default: 7d)\\nAlerts sent to log channel automatically\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"âš”ï¸ MODERATION MATRIX\",\n        value=\"`/ban` - Ban user\\n`/kick` - Kick user\\n`/mute` `/unmute` - Mute/unmute user\\n`/tempmute <user> <time>` - Discord timeout (max 28d)\\n`/purge <1-100>` - Bulk message deletion\\n`/warn` - Warn user\\n`/lock` `/unlock` - Lock/unlock channel\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸ§  AI NEURAL LINK\",\n        value=\"**@mention me** to activate AI assistant\\n`Responds in EN/HU based on server language`\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸµ MUSIC SYSTEM (ğŸ¥ YouTube â€¢ ğŸŸ¢ Spotify â€¢ â˜ï¸ SoundCloud)\",\n        value=f\"`/play <song>` - Play music from any platform\\n`/pause` `/resume` - Pause/resume playback\\n`/skip` - Skip to next song\\n`/stop` - Stop and disconnect\\n`/queue` - Show music queue\\n`/nowplaying` - Current track info\\n`/loop` - Toggle loop mode\\n`/volume <0-100>` - Adjust volume\\n*Also supports `{prefix}` prefix for all commands*\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸ® ENTERTAINMENT SYSTEMS\",\n        value=\"`/rps` - Rock-Paper-Scissors\\n`/tictactoe` - Tic-Tac-Toe\\n`/meme` - Generate memes\\n`/8ball` - Magic 8-ball\\n`/coinflip` - Flip coin\\n`/dice` - Roll dice\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸ ENGAGEMENT PROTOCOLS\",\n        value=\"`/poll` - Interactive polls\\n`/giveaway` - Prize systems\\n`/ticket` - Support tickets\\n`/createrole` - Role management\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸ·ï¸ NAME AUTOMATION\",\n        value=\"`/setprefix <@role> <prefix>` - Set role prefix\\n`/removeprefix <@role>` - Remove role prefix\\n`/viewprefixes` - View all prefixes\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸŒ SYSTEM CONFIGURATION\",\n        value=\"`/setlang <en/hu>` - Language switch\\n`/setbotprefix <prefix>` - Change bot prefix\\n`/setwebhook <url>` - Logging webhook\\n`/ping` - Check latency\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸ‘‘ OWNER COMMANDS (Bot Owner Only)\",\n        value=\"`/servers` - List all servers (name + ID)\\n`/createinvite <server_id>` - Create permanent invite\\n`/addcc <name> <response>` - Add custom command\\n`/rcc <name>` - Remove custom command\\n`/mcc <name> <response>` - Modify custom command\",\n        inline=False\n    )\n    \n    embed.add_field(\n        name=\"ğŸŒ WEB RESOURCES\",\n        value=\"[ğŸ“– Full Command List](https://shadowmod.net/help)\\n[ğŸ“Š Live Dashboard](https://shadowmod.net/dashboard)\",\n        inline=False\n    )\n    \n    embed.set_footer(text=\"âš¡ Made by MoonlightVFX | 52 Slash Commands Ready âš¡\")\n    embed.set_thumbnail(url=ctx.bot.user.display_avatar.url)\n    \n    await ctx.send(embed=embed)\n\n@bot.command(name='ping')\nasync def ping_command(ctx):\n    latency = round(bot.latency * 1000)\n    \n    # Determine latency color\n    if latency < 100:\n        color = 0x00F3FF  # Neon cyan - excellent\n        status = \"âš¡ OPTIMAL\"\n    elif latency < 200:\n        color = 0x8B00FF  # Neon purple - good\n        status = \"âœ… STABLE\"\n    else:\n        color = 0xFF006E  # Neon pink - slow\n        status = \"âš ï¸ DEGRADED\"\n    \n    embed = discord.Embed(\n        title=f\"ğŸ“¡ SYSTEM RESPONSE | {status}\",\n        description=f\"```ansi\\n\\u001b[1;36mLatency: {latency}ms\\u001b[0m\\n```\",\n        color=color\n    )\n    embed.add_field(name=\"Status\", value=status, inline=True)\n    embed.add_field(name=\"Response Time\", value=f\"{latency}ms\", inline=True)\n    embed.set_footer(text=\"âš¡ Neural Network Active\")\n    \n    await ctx.send(embed=embed)\n\nif __name__ == '__main__':\n    TOKEN = os.getenv('DISCORD_TOKEN')\n    if not TOKEN:\n        print(\"ERROR: DISCORD_TOKEN not found in environment variables!\")\n        print(\"Please set up your Discord bot token.\")\n    else:\n        bot.run(TOKEN)\n","size_bytes":8230},"cogs/moderation.py":{"content":"import discord\nfrom discord.ext import commands, tasks\nfrom datetime import datetime, timedelta, timezone\nimport config\nimport asyncio\n\nclass Moderation(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.check_temp_actions.start()\n    \n    def cog_unload(self):\n        self.check_temp_actions.cancel()\n    \n    async def send_log(self, embed):\n        cfg = config.load_config()\n        log_channel_id = cfg.get('log_channel_id')\n        \n        if log_channel_id:\n            log_channel = self.bot.get_channel(log_channel_id)\n            if log_channel:\n                await log_channel.send(embed=embed)\n    \n    @tasks.loop(minutes=1)\n    async def check_temp_actions(self):\n        cfg = config.load_config()\n        current_time = datetime.now(timezone.utc).timestamp()\n        \n        temp_bans = cfg.get('temp_bans', {})\n        for guild_id, bans in list(temp_bans.items()):\n            guild = self.bot.get_guild(int(guild_id))\n            if not guild:\n                continue\n            \n            for user_id, unban_time in list(bans.items()):\n                if current_time >= unban_time:\n                    try:\n                        user = await self.bot.fetch_user(int(user_id))\n                        await guild.unban(user, reason=\"Temporary ban expired\")\n                        del temp_bans[guild_id][user_id]\n                    except:\n                        pass\n        \n        config.save_config(cfg)\n    \n    @check_temp_actions.before_loop\n    async def before_check_temp_actions(self):\n        await self.bot.wait_until_ready()\n    \n    @commands.command(name='ban')\n    @commands.has_permissions(ban_members=True)\n    async def ban_user(self, ctx, member: discord.Member, *, reason=\"No reason provided\"):\n        if member.top_role >= ctx.author.top_role:\n            await ctx.send(\"âŒ You cannot ban this user!\")\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ”¨ User Banned\",\n            description=f\"**User:** {member.mention}\\n**Reason:** {reason}\\n**Moderator:** {ctx.author.mention}\",\n            color=0xFF006E,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        await member.ban(reason=reason)\n        await ctx.send(embed=embed)\n        await self.send_log(embed)\n    \n    @commands.command(name='kick')\n    @commands.has_permissions(kick_members=True)\n    async def kick_user(self, ctx, member: discord.Member, *, reason=\"No reason provided\"):\n        if member.top_role >= ctx.author.top_role:\n            await ctx.send(\"âŒ You cannot kick this user!\")\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ‘¢ User Kicked\",\n            description=f\"**User:** {member.mention}\\n**Reason:** {reason}\\n**Moderator:** {ctx.author.mention}\",\n            color=0xFF006E,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        await member.kick(reason=reason)\n        await ctx.send(embed=embed)\n        await self.send_log(embed)\n    \n    @commands.command(name='mute')\n    @commands.has_permissions(moderate_members=True)\n    async def mute_user(self, ctx, member: discord.Member):\n        cfg = config.load_config()\n        muted_roles = cfg.get('muted_roles', {})\n        muted_role_id = muted_roles.get(str(ctx.guild.id))\n        \n        if not muted_role_id:\n            muted_role = await ctx.guild.create_role(name=\"Muted\", color=discord.Color(0x0066FF))\n            \n            for channel in ctx.guild.channels:\n                await channel.set_permissions(muted_role, send_messages=False, speak=False)\n            \n            if 'muted_roles' not in cfg:\n                cfg['muted_roles'] = {}\n            cfg['muted_roles'][str(ctx.guild.id)] = muted_role.id\n            config.save_config(cfg)\n        else:\n            muted_role = ctx.guild.get_role(int(muted_role_id))\n            if not muted_role:\n                await ctx.send(\"âŒ Muted role not found! Creating new one...\")\n                muted_role = await ctx.guild.create_role(name=\"Muted\", color=discord.Color(0x0066FF))\n                for channel in ctx.guild.channels:\n                    await channel.set_permissions(muted_role, send_messages=False, speak=False)\n                cfg['muted_roles'][str(ctx.guild.id)] = muted_role.id\n                config.save_config(cfg)\n        \n        await member.add_roles(muted_role)\n        \n        embed = discord.Embed(\n            title=\"ğŸ”‡ User Muted\",\n            description=f\"**User:** {member.mention}\\n**Moderator:** {ctx.author.mention}\",\n            color=0x0066FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        await ctx.send(embed=embed)\n        await self.send_log(embed)\n    \n    @commands.command(name='unmute')\n    @commands.has_permissions(moderate_members=True)\n    async def unmute_user(self, ctx, member: discord.Member):\n        cfg = config.load_config()\n        muted_roles = cfg.get('muted_roles', {})\n        muted_role_id = muted_roles.get(str(ctx.guild.id))\n        \n        if not muted_role_id:\n            await ctx.send(\"âŒ No muted role found!\")\n            return\n        \n        muted_role = ctx.guild.get_role(int(muted_role_id))\n        if not muted_role:\n            await ctx.send(\"âŒ Muted role not found!\")\n            return\n        \n        if muted_role in member.roles:\n            await member.remove_roles(muted_role)\n            \n            embed = discord.Embed(\n                title=\"ğŸ”Š User Unmuted\",\n                description=f\"**User:** {member.mention}\\n**Moderator:** {ctx.author.mention}\",\n                color=0x00F3FF,\n                timestamp=datetime.now(timezone.utc)\n            )\n            \n            await ctx.send(embed=embed)\n            await self.send_log(embed)\n        else:\n            await ctx.send(\"âŒ User is not muted!\")\n    \n    @commands.command(name='tempmute')\n    @commands.has_permissions(moderate_members=True)\n    async def temp_mute(self, ctx, member: discord.Member, duration: str):\n        time_units = {'s': 1, 'm': 60, 'h': 3600, 'd': 86400}\n        \n        try:\n            time_amount = int(duration[:-1])\n            time_unit = duration[-1]\n        except:\n            await ctx.send(\"âŒ Invalid time format! Use: 10s, 5m, 2h, 1d\")\n            return\n        \n        if time_unit not in time_units:\n            await ctx.send(\"âŒ Invalid time format! Use: 10s, 5m, 2h, 1d\")\n            return\n        \n        seconds = time_amount * time_units[time_unit]\n        \n        if seconds > 2419200:\n            await ctx.send(\"âŒ Maximum timeout duration is 28 days!\")\n            return\n        \n        if seconds < 1:\n            await ctx.send(\"âŒ Timeout duration must be at least 1 second!\")\n            return\n        \n        timeout_until = datetime.now(timezone.utc) + timedelta(seconds=seconds)\n        \n        try:\n            await member.timeout(timeout_until, reason=f\"Timed out by {ctx.author}\")\n            \n            embed = discord.Embed(\n                title=\"â±ï¸ User Timed Out\",\n                description=f\"**User:** {member.mention}\\n**Duration:** {duration}\\n**Moderator:** {ctx.author.mention}\",\n                color=0x0066FF,\n                timestamp=datetime.now(timezone.utc)\n            )\n            embed.add_field(name=\"Timeout Until\", value=f\"<t:{int(timeout_until.timestamp())}:F>\", inline=False)\n            \n            await ctx.send(embed=embed)\n            await self.send_log(embed)\n        except discord.Forbidden:\n            await ctx.send(\"âŒ I don't have permission to timeout this user!\")\n        except discord.HTTPException as e:\n            await ctx.send(f\"âŒ Failed to timeout user: {str(e)}\")\n    \n    @commands.command(name='tempban')\n    @commands.has_permissions(ban_members=True)\n    async def temp_ban(self, ctx, member: discord.Member, duration: str, *, reason=\"No reason provided\"):\n        time_units = {'s': 1, 'm': 60, 'h': 3600, 'd': 86400}\n        time_amount = int(duration[:-1])\n        time_unit = duration[-1]\n        \n        if time_unit not in time_units:\n            await ctx.send(\"âŒ Invalid time format! Use: 10s, 5m, 2h, 1d\")\n            return\n        \n        seconds = time_amount * time_units[time_unit]\n        unban_time = datetime.now(timezone.utc).timestamp() + seconds\n        \n        await member.ban(reason=reason)\n        \n        cfg = config.load_config()\n        if 'temp_bans' not in cfg:\n            cfg['temp_bans'] = {}\n        if str(ctx.guild.id) not in cfg['temp_bans']:\n            cfg['temp_bans'][str(ctx.guild.id)] = {}\n        cfg['temp_bans'][str(ctx.guild.id)][str(member.id)] = unban_time\n        config.save_config(cfg)\n        \n        embed = discord.Embed(\n            title=\"ğŸ”¨ User Temporarily Banned\",\n            description=f\"**User:** {member.mention}\\n**Duration:** {duration}\\n**Reason:** {reason}\\n**Moderator:** {ctx.author.mention}\",\n            color=0xFF006E,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        await ctx.send(embed=embed)\n        await self.send_log(embed)\n    \n    @commands.command(name='lock')\n    @commands.has_permissions(manage_channels=True)\n    async def lock_channel(self, ctx):\n        await ctx.channel.set_permissions(ctx.guild.default_role, send_messages=False)\n        \n        embed = discord.Embed(\n            title=\"ğŸ”’ Channel Locked\",\n            description=f\"This channel has been locked by {ctx.author.mention}\",\n            color=0xFF006E\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='unlock')\n    @commands.has_permissions(manage_channels=True)\n    async def unlock_channel(self, ctx):\n        await ctx.channel.set_permissions(ctx.guild.default_role, send_messages=True)\n        \n        embed = discord.Embed(\n            title=\"ğŸ”“ Channel Unlocked\",\n            description=f\"This channel has been unlocked by {ctx.author.mention}\",\n            color=0x00F3FF\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='warn')\n    @commands.has_permissions(moderate_members=True)\n    async def warn_user(self, ctx, member: discord.Member, *, reason=\"No reason provided\"):\n        cfg = config.load_config()\n        if 'warnings' not in cfg:\n            cfg['warnings'] = {}\n        \n        user_id = str(member.id)\n        if user_id not in cfg['warnings']:\n            cfg['warnings'][user_id] = []\n        \n        warning = {\n            'reason': reason,\n            'moderator': str(ctx.author.id),\n            'timestamp': datetime.now(timezone.utc).isoformat()\n        }\n        cfg['warnings'][user_id].append(warning)\n        config.save_config(cfg)\n        \n        embed = discord.Embed(\n            title=\"âš ï¸ User Warned\",\n            description=f\"**User:** {member.mention}\\n**Reason:** {reason}\\n**Moderator:** {ctx.author.mention}\\n**Total Warnings:** {len(cfg['warnings'][user_id])}\",\n            color=discord.Color.gold(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        await ctx.send(embed=embed)\n        await self.send_log(embed)\n    \n    @commands.command(name='warnings')\n    @commands.has_permissions(moderate_members=True)\n    async def check_warnings(self, ctx, member: discord.Member):\n        cfg = config.load_config()\n        user_id = str(member.id)\n        \n        if 'warnings' not in cfg or user_id not in cfg['warnings']:\n            await ctx.send(f\"âœ… {member.mention} has no warnings!\")\n            return\n        \n        warnings = cfg['warnings'][user_id]\n        \n        embed = discord.Embed(\n            title=f\"âš ï¸ Warnings for {member}\",\n            description=f\"Total warnings: {len(warnings)}\",\n            color=discord.Color.gold()\n        )\n        \n        for i, warn in enumerate(warnings[-5:], 1):\n            moderator = ctx.guild.get_member(int(warn['moderator']))\n            mod_name = moderator.mention if moderator else \"Unknown\"\n            embed.add_field(\n                name=f\"Warning #{i}\",\n                value=f\"**Reason:** {warn['reason']}\\n**By:** {mod_name}\\n**Date:** {warn['timestamp'][:10]}\",\n                inline=False\n            )\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='purge')\n    @commands.has_permissions(manage_messages=True)\n    async def purge_messages(self, ctx, amount: int):\n        from translations import get_text\n        \n        if amount < 1 or amount > 100:\n            await ctx.send(get_text(ctx.guild.id, 'purge_invalid'))\n            return\n        \n        try:\n            deleted = await ctx.channel.purge(limit=amount + 1)\n            \n            embed = discord.Embed(\n                title=get_text(ctx.guild.id, 'messages_purged'),\n                description=get_text(ctx.guild.id, 'messages_purged_desc', len(deleted) - 1),\n                color=0xFF006E,\n                timestamp=datetime.now(timezone.utc)\n            )\n            embed.add_field(name=get_text(ctx.guild.id, 'moderator'), value=ctx.author.mention)\n            \n            msg = await ctx.send(embed=embed)\n            await asyncio.sleep(5)\n            await msg.delete()\n            \n            await self.send_log(embed)\n            \n        except discord.Forbidden:\n            await ctx.send(\"âŒ I don't have permission to delete messages!\")\n        except Exception as e:\n            await ctx.send(f\"âŒ An error occurred: {str(e)}\")\n\nasync def setup(bot):\n    await bot.add_cog(Moderation(bot))\n","size_bytes":13498},"cogs/fun.py":{"content":"import discord\nfrom discord.ext import commands\nimport aiohttp\nimport random\nimport config\nfrom translations import get_text, get_guild_language\nfrom urllib.parse import quote\n\nclass Fun(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.sounds = [\n            \"ğŸµ *Ding dong!*\",\n            \"ğŸ”” *Ring ring!*\",\n            \"ğŸ“¯ *Toot toot!*\",\n            \"ğŸº *Doot doot!*\",\n            \"ğŸ¥ *Ba dum tss!*\",\n            \"ğŸ¸ *Strum strum!*\",\n            \"ğŸ¹ *Piano notes!*\",\n            \"ğŸ· *Smooth jazz!*\",\n            \"ğŸ“¢ *Honk honk!*\",\n            \"ğŸ”Š *Beep boop!*\"\n        ]\n        \n        self.meme_templates_en = [\n            (\"drake\", \"Old boring way\", \"Cool new way\"),\n            (\"buzz\", \"Memes\", \"Memes everywhere\"),\n            (\"doge\", \"Such wow\", \"Very meme\"),\n            (\"yoda\", \"Do or do not\", \"There is no try\"),\n            (\"both\", \"Why not both?\", \"Both is good\"),\n            (\"aliens\", \"I'm not saying it was\", \"But it was\"),\n            (\"interesting\", \"That's very\", \"Interesting\"),\n            (\"disaster\", \"I see this as\", \"An absolute win\"),\n            (\"fine\", \"This is fine\", \"Everything is fine\"),\n            (\"think\", \"Modern problems\", \"Modern solutions\"),\n        ]\n        \n        self.meme_templates_hu = [\n            (\"drake\", \"RÃ©gi unalmas mÃ³dszer\", \"MenÅ‘ Ãºj mÃ³dszer\"),\n            (\"buzz\", \"MÃ©mek\", \"MÃ©mek mindenhol\"),\n            (\"doge\", \"Ilyen hÅ±ha\", \"Nagyon mÃ©m\"),\n            (\"yoda\", \"Tedd vagy ne tedd\", \"Nincs prÃ³ba\"),\n            (\"both\", \"MiÃ©rt ne mindkettÅ‘?\", \"MindkettÅ‘ jÃ³\"),\n            (\"aliens\", \"Nem azt mondom hogy az volt\", \"De az volt\"),\n            (\"interesting\", \"Ez nagyon\", \"Ã‰rdekes\"),\n            (\"disaster\", \"Ezt Ãºgy lÃ¡tom\", \"AbszolÃºt gyÅ‘zelem\"),\n            (\"fine\", \"Ez rendben van\", \"Minden rendben\"),\n            (\"think\", \"Modern problÃ©mÃ¡k\", \"Modern megoldÃ¡sok\"),\n        ]\n    \n    @commands.command(name='meme')\n    async def random_meme(self, ctx):\n        lang = get_guild_language(ctx.guild.id)\n        \n        templates = self.meme_templates_hu if lang == 'hu' else self.meme_templates_en\n        template_name, top_text, bottom_text = random.choice(templates)\n        \n        top_text_encoded = quote(top_text, safe='')\n        bottom_text_encoded = quote(bottom_text, safe='')\n        \n        meme_url = f\"https://api.memegen.link/images/{template_name}/{top_text_encoded}/{bottom_text_encoded}.png\"\n        \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.head(meme_url, timeout=aiohttp.ClientTimeout(total=5)) as response:\n                    if response.status != 200:\n                        raise Exception(\"Meme API unavailable\")\n            \n            embed = discord.Embed(\n                title=get_text(ctx.guild.id, 'meme_title'),\n                color=discord.Color.random()\n            )\n            embed.set_image(url=meme_url)\n            embed.set_footer(text=get_text(ctx.guild.id, 'generated_meme'))\n            \n            await ctx.send(embed=embed)\n        except Exception:\n            embed = discord.Embed(\n                title=get_text(ctx.guild.id, 'meme_title'),\n                description=f\"**{top_text}**\\n\\n*{bottom_text}*\",\n                color=discord.Color.random()\n            )\n            embed.set_footer(text=get_text(ctx.guild.id, 'generated_meme'))\n            await ctx.send(embed=embed)\n    \n    \n    @commands.command(name='sound')\n    async def random_sound(self, ctx):\n        sound = random.choice(self.sounds)\n        \n        embed = discord.Embed(\n            title=\"ğŸ”Š Random Sound\",\n            description=sound,\n            color=discord.Color.random()\n        )\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='8ball')\n    async def eight_ball(self, ctx, *, question: str = \"\"):\n        if not question:\n            await ctx.send(\"âŒ Please ask a question!\")\n            return\n        \n        responses = [\n            \"Yes, definitely! âœ…\",\n            \"It is certain! âœ…\",\n            \"Without a doubt! âœ…\",\n            \"Yes! âœ…\",\n            \"Most likely! âœ…\",\n            \"Outlook good! âœ…\",\n            \"Signs point to yes! âœ…\",\n            \"Reply hazy, try again! ğŸ¤”\",\n            \"Ask again later! ğŸ¤”\",\n            \"Better not tell you now! ğŸ¤”\",\n            \"Cannot predict now! ğŸ¤”\",\n            \"Concentrate and ask again! ğŸ¤”\",\n            \"Don't count on it! âŒ\",\n            \"My reply is no! âŒ\",\n            \"My sources say no! âŒ\",\n            \"Outlook not so good! âŒ\",\n            \"Very doubtful! âŒ\"\n        ]\n        \n        answer = random.choice(responses)\n        \n        embed = discord.Embed(\n            title=\"ğŸ± Magic 8 Ball\",\n            color=discord.Color.purple()\n        )\n        embed.add_field(name=\"Question\", value=question, inline=False)\n        embed.add_field(name=\"Answer\", value=answer, inline=False)\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='coinflip')\n    async def coin_flip(self, ctx):\n        result = random.choice(['Heads', 'Tails'])\n        emoji = 'ğŸª™'\n        \n        embed = discord.Embed(\n            title=f\"{emoji} Coin Flip\",\n            description=f\"**Result:** {result}!\",\n            color=discord.Color.gold()\n        )\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='roll')\n    async def dice_roll(self, ctx, dice: str = \"1d6\"):\n        try:\n            rolls, sides = map(int, dice.split('d'))\n            \n            if rolls > 100 or sides > 1000:\n                await ctx.send(\"âŒ That's too many dice or sides!\")\n                return\n            \n            results = [random.randint(1, sides) for _ in range(rolls)]\n            total = sum(results)\n            \n            embed = discord.Embed(\n                title=\"ğŸ² Dice Roll\",\n                description=f\"Rolling {rolls}d{sides}\",\n                color=0x8B00FF\n            )\n            \n            if len(results) <= 20:\n                embed.add_field(name=\"Results\", value=\", \".join(map(str, results)), inline=False)\n            \n            embed.add_field(name=\"Total\", value=str(total), inline=False)\n            \n            await ctx.send(embed=embed)\n        except:\n            await ctx.send(\"âŒ Invalid format! Use: `!roll 2d6` (rolls, d, sides)\")\n\nasync def setup(bot):\n    await bot.add_cog(Fun(bot))\n","size_bytes":6459},"cogs/games.py":{"content":"import discord\nfrom discord.ext import commands\nfrom discord.ui import Button, View\nimport random\n\nclass RPSView(View):\n    def __init__(self, ctx):\n        super().__init__(timeout=60)\n        self.ctx = ctx\n        self.value = None\n    \n    @discord.ui.button(label='ğŸª¨ Rock', style=discord.ButtonStyle.primary)\n    async def rock(self, interaction: discord.Interaction, button: Button):\n        await self.process_choice(interaction, 'rock')\n    \n    @discord.ui.button(label='ğŸ“„ Paper', style=discord.ButtonStyle.primary)\n    async def paper(self, interaction: discord.Interaction, button: Button):\n        await self.process_choice(interaction, 'paper')\n    \n    @discord.ui.button(label='âœ‚ï¸ Scissors', style=discord.ButtonStyle.primary)\n    async def scissors(self, interaction: discord.Interaction, button: Button):\n        await self.process_choice(interaction, 'scissors')\n    \n    async def process_choice(self, interaction: discord.Interaction, choice):\n        if interaction.user.id != self.ctx.author.id:\n            await interaction.response.send_message(\"âŒ This is not your game!\", ephemeral=True)\n            return\n        \n        bot_choice = random.choice(['rock', 'paper', 'scissors'])\n        \n        emojis = {'rock': 'ğŸª¨', 'paper': 'ğŸ“„', 'scissors': 'âœ‚ï¸'}\n        \n        if choice == bot_choice:\n            result = \"It's a tie!\"\n            color = discord.Color.gold()\n        elif (choice == 'rock' and bot_choice == 'scissors') or \\\n             (choice == 'paper' and bot_choice == 'rock') or \\\n             (choice == 'scissors' and bot_choice == 'paper'):\n            result = \"You win! ğŸ‰\"\n            color = 0x00F3FF\n        else:\n            result = \"You lose! ğŸ˜¢\"\n            color = 0xFF006E\n        \n        embed = discord.Embed(\n            title=\"ğŸ® Rock Paper Scissors\",\n            description=f\"**Your choice:** {emojis[choice]} {choice.title()}\\n**My choice:** {emojis[bot_choice]} {bot_choice.title()}\\n\\n**Result:** {result}\",\n            color=color\n        )\n        \n        await interaction.response.edit_message(embed=embed, view=None)\n        self.stop()\n\nclass TicTacToeButton(Button):\n    def __init__(self, x: int, y: int):\n        super().__init__(style=discord.ButtonStyle.secondary, label='\\u200b', row=y)\n        self.x = x\n        self.y = y\n    \n    async def callback(self, interaction: discord.Interaction):\n        view: TicTacToeView = self.view\n        \n        if interaction.user.id != view.current_player.id:\n            await interaction.response.send_message(\"âŒ It's not your turn!\", ephemeral=True)\n            return\n        \n        if view.board[self.y][self.x] != 0:\n            await interaction.response.send_message(\"âŒ This position is already taken!\", ephemeral=True)\n            return\n        \n        view.board[self.y][self.x] = view.current_marker\n        self.style = discord.ButtonStyle.danger if view.current_marker == 1 else discord.ButtonStyle.success\n        self.label = 'X' if view.current_marker == 1 else 'O'\n        self.disabled = True\n        \n        winner = view.check_winner()\n        \n        if winner:\n            for child in view.children:\n                child.disabled = True\n            \n            if winner == 3:\n                embed = discord.Embed(\n                    title=\"ğŸ® Tic Tac Toe - Tie!\",\n                    description=\"The game ended in a tie!\",\n                    color=discord.Color.gold()\n                )\n            else:\n                winner_player = view.player1 if winner == 1 else view.player2\n                embed = discord.Embed(\n                    title=\"ğŸ® Tic Tac Toe - Winner!\",\n                    description=f\"{winner_player.mention} wins! ğŸ‰\",\n                    color=0x00F3FF\n                )\n            \n            await interaction.response.edit_message(embed=embed, view=view)\n            view.stop()\n        else:\n            view.current_marker = 2 if view.current_marker == 1 else 1\n            view.current_player = view.player2 if view.current_marker == 2 else view.player1\n            \n            embed = discord.Embed(\n                title=\"ğŸ® Tic Tac Toe\",\n                description=f\"**Current turn:** {view.current_player.mention} ({'X' if view.current_marker == 1 else 'O'})\",\n                color=0x8B00FF\n            )\n            embed.add_field(name=\"Players\", value=f\"âŒ {view.player1.mention}\\nâ­• {view.player2.mention}\")\n            \n            await interaction.response.edit_message(embed=embed, view=view)\n\nclass TicTacToeView(View):\n    def __init__(self, player1, player2):\n        super().__init__(timeout=300)\n        self.player1 = player1\n        self.player2 = player2\n        self.current_player = player1\n        self.current_marker = 1\n        self.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n        \n        for y in range(3):\n            for x in range(3):\n                self.add_item(TicTacToeButton(x, y))\n    \n    def check_winner(self):\n        for row in self.board:\n            if row[0] == row[1] == row[2] != 0:\n                return row[0]\n        \n        for col in range(3):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != 0:\n                return self.board[0][col]\n        \n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != 0:\n            return self.board[0][0]\n        \n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != 0:\n            return self.board[0][2]\n        \n        if all(self.board[y][x] != 0 for y in range(3) for x in range(3)):\n            return 3\n        \n        return None\n\nclass Games(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name='rps')\n    async def rock_paper_scissors(self, ctx):\n        embed = discord.Embed(\n            title=\"ğŸ® Rock Paper Scissors\",\n            description=\"Choose your move!\",\n            color=0x8B00FF\n        )\n        \n        view = RPSView(ctx)\n        await ctx.send(embed=embed, view=view)\n    \n    @commands.command(name='tictactoe')\n    async def tic_tac_toe(self, ctx, opponent: discord.Member):\n        if opponent.bot:\n            await ctx.send(\"âŒ You cannot play against a bot!\")\n            return\n        \n        if opponent.id == ctx.author.id:\n            await ctx.send(\"âŒ You cannot play against yourself!\")\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ® Tic Tac Toe\",\n            description=f\"**Current turn:** {ctx.author.mention} (X)\",\n            color=0x8B00FF\n        )\n        embed.add_field(name=\"Players\", value=f\"âŒ {ctx.author.mention}\\nâ­• {opponent.mention}\")\n        \n        view = TicTacToeView(ctx.author, opponent)\n        await ctx.send(embed=embed, view=view)\n\nasync def setup(bot):\n    await bot.add_cog(Games(bot))\n","size_bytes":6850},"replit.md":{"content":"# âš¡ SHADOW-MOD âœ¨ | Futuristic Discord Bot\n\n## Overview\n**Next-Gen Discord Moderation System v2.0 FUTURISTIC**\n\nA comprehensive Discord bot built with Python featuring a cyberpunk neon theme and:\n- **Multilanguage support (English & Hungarian)**\n- **AI Chat Assistant** - OpenAI-powered responses in designated channels\n- **Music System** - Play music from YouTube, Spotify, and SoundCloud with queue management\n- **Verification system** - Button-based member verification with anti-alt protection\n- Automated ticket system with buttons\n- Anti-alt account detection\n- Advanced logging to Discord channels\n- **Webhook logging system for bot errors and events**\n- Full moderation suite (ban, kick, mute, tempmute, tempban, lock, unlock, warnings)\n- Interactive games (Rock-Paper-Scissors, Tic-Tac-Toe)\n- Fun commands (memes, sounds, 8ball, coinflip, dice)\n- Poll system with button voting and live results\n- Role management (create, delete, assign, remove)\n- Giveaway system with automatic winner selection\n- Name automation with role-based prefixes\n- **Dual prefix support (! and /) for active developer badge**\n- **52 slash commands for Active Developer Badge maintenance**\n- **Custom Commands** - Owner can create custom text commands with /addcc, /rcc, /mcc\n- **Music slash commands** - All music features now support both ! and / prefixes\n- **Admin Commands** - Owner-only server management (list servers, create invites)\n- **Verification system** - Button-based verification with anti-alt checks\n- **Information Commands** - Server info, bot info, user info with badges\n- **Support & Web Links** - Quick access to support server and live dashboard\n\nAll features use Discord embeds and button components for a modern user experience.\n\n## Project Structure\n```\n.\nâ”œâ”€â”€ bot_launcher.py      # Combined launcher for bot + web server\nâ”œâ”€â”€ main.py              # Main bot entry point (dual prefix support)\nâ”œâ”€â”€ web_server.py        # Flask web server for stats dashboard\nâ”œâ”€â”€ bot_stats.json       # Shared stats file between bot and web server\nâ”œâ”€â”€ config.py            # Configuration management\nâ”œâ”€â”€ translations.py      # Multilanguage translation system\nâ”œâ”€â”€ templates/           # HTML templates for web dashboard\nâ”‚   â”œâ”€â”€ index.html       # Futuristic stats page\nâ”‚   â””â”€â”€ help.html        # Command documentation page\nâ”œâ”€â”€ static/              # Static assets for web server\nâ”‚   â”œâ”€â”€ css/style.css    # Cyberpunk neon theme styles\nâ”‚   â””â”€â”€ js/script.js     # Interactive dashboard animations\nâ”œâ”€â”€ cogs/                # Bot feature modules\nâ”‚   â”œâ”€â”€ tickets.py       # Ticket system\nâ”‚   â”œâ”€â”€ antialt.py       # Anti-alt detection\nâ”‚   â”œâ”€â”€ logging.py       # Event logging\nâ”‚   â”œâ”€â”€ moderation.py    # Moderation commands\nâ”‚   â”œâ”€â”€ games.py         # Interactive games\nâ”‚   â”œâ”€â”€ fun.py           # Fun commands (including multilingual memes)\nâ”‚   â”œâ”€â”€ polls.py         # Poll system\nâ”‚   â”œâ”€â”€ roles.py         # Role management\nâ”‚   â”œâ”€â”€ giveaways.py     # Giveaway system\nâ”‚   â”œâ”€â”€ nameauto.py      # Name automation\nâ”‚   â”œâ”€â”€ webhook_logging.py  # Webhook logging for bot errors\nâ”‚   â”œâ”€â”€ language.py      # Language switching commands\nâ”‚   â”œâ”€â”€ aichat.py        # AI chat assistant with OpenAI\nâ”‚   â”œâ”€â”€ verify.py        # Member verification with anti-alt checks\nâ”‚   â”œâ”€â”€ info.py          # Information commands (serverinfo, botinfo, userinfo, etc)\nâ”‚   â”œâ”€â”€ music.py         # Music player (YouTube, Spotify, SoundCloud)\nâ”‚   â”œâ”€â”€ admin.py         # Owner-only admin commands (servers, createinvite)\nâ”‚   â”œâ”€â”€ customcommands.py  # Custom command management system\nâ”‚   â””â”€â”€ slash_commands.py  # Slash command implementations (52 commands total)\nâ”œâ”€â”€ .env                 # Environment variables (DISCORD_TOKEN)\nâ”œâ”€â”€ bot_config.json      # Runtime configuration (auto-generated)\nâ””â”€â”€ README.md            # User documentation\n```\n\n## Setup Requirements\n1. Discord bot token must be set in environment as `DISCORD_TOKEN`\n2. **Optional:** OpenAI API key as `OPENAI_API_KEY` for AI chat feature\n3. **Optional:** Spotify API credentials (`SPOTIFY_CLIENT_ID`, `SPOTIFY_CLIENT_SECRET`) for Spotify track metadata\n4. Bot requires these Discord intents: members, messages, message_content, guilds\n5. Recommended permissions: Administrator (or manage_channels, ban_members, kick_members, manage_roles, manage_messages, connect, speak)\n6. **Music System:** Uses public Lavalink nodes (automatically connects to available nodes). No additional setup required for basic music functionality.\n\n## Recent Changes (November 2025)\n- **ğŸ¨ CUSTOM COMMANDS SYSTEM** - Added 3 owner-only commands for custom command management: /addcc (add), /rcc (remove), /mcc (modify). Bot owner can create custom text-based commands that users can trigger with the server's prefix. Commands stored in bot_config.json, fully integrated with dynamic prefix system.\n- **âš™ï¸ CUSTOM PREFIX SYSTEM** - Added /setbotprefix command allowing server admins to change the bot's command prefix (default: !). Help command now displays the current prefix for each server. Slash commands (/) always work regardless of prefix setting.\n- **ğŸ“– HELP PAGE UPDATE** - Added /help command to the Information Systems section of the command documentation page (help.html)\n- **ğŸ”§ DUPLICATE API CALLS FIX** - Fixed multiple API stats requests happening simultaneously. Root cause: setInterval auto-refresh running multiple instances when script loaded multiple times. Solution: added window-level flag check to prevent duplicate intervals.\n- **ğŸ¨ CYAN BOX FIX (RESOLVED)** - Fixed persistent cyan bordered rectangle around hero section. Root cause: `.logo-glow` element with radial-gradient cyan background (300px x 300px) was rendering as visible frame effect around the SHADOW-MOD title area. Solution: disabled `.logo-glow` element entirely. (User discovered the root cause!)\n- **ğŸ“± MOBILE NAVIGATION FIX** - Significantly enlarged mobile navigation buttons for better tap targets. Tablet (768px): 48px height with larger padding (14x20px). Small mobile (480px): 44px height meeting WCAG standards with 1.2em emoji icons. Buttons now 22-50% larger and much easier to click on all mobile devices.\n- **ğŸ¨ UI/UX IMPROVEMENTS** - Reduced excessive glow effects on text, slowed down and dimmed animated starfield background for better eye comfort, added dark text outlines/shadows for improved readability against all backgrounds. Fixed navigation button hitboxes with 50% larger clickable areas, proper cursor pointers, and 44px minimum height (WCAG compliant). Website is now easier on the eyes while maintaining cyberpunk aesthetic.\n- **ğŸ“¬ SERVER JOIN NOTIFICATIONS** - Bot now sends DM notification to owner when invited to new servers. Includes server info (name, ID, member count, owner details, creation date) and updated total server count.\n- **ğŸ“‹ LOGGING OPTIMIZATION** - Fixed duplicate logging when members join. Consolidated logging.py and antialt.py into single comprehensive message that shows join info + alt detection warning (if applicable) in one embed. Cleaner log channel with no duplication.\n- **ğŸ”§ ADMIN COMMANDS** - Added owner-only server management commands: /servers (list all servers with name/ID) and /createinvite <server_id> (create permanent invite). Total slash commands: 48\n- **ğŸµ LAVALINK INTEGRATION** - Migrated music system to Lavalink for cloud environment compatibility. Uses public Lavalink nodes with automatic fallback. Supports YouTube, Spotify (metadata), and SoundCloud playback via wavelink library.\n- **ğŸµ MUSIC SLASH COMMANDS** - Added 9 music slash commands (/play, /pause, /resume, /skip, /stop, /queue, /nowplaying, /loop, /volume)\n- **ğŸ“– UPDATED HELP SYSTEM** - Refreshed !help, /help, and help.html to prominently display music platform support (YouTube, Spotify, SoundCloud) with dual prefix info\n- **ğŸµ MUSIC SYSTEM** - Complete music player with YouTube, Spotify, and SoundCloud support via Lavalink. Features: play, pause, resume, skip, stop, queue, nowplaying, loop, and volume commands\n- **ğŸ‘¤ CREATOR BRANDING** - Updated all \"v2.0 FUTURISTIC\" references to \"Made by MoonlightVFX\" across website, bot commands, and documentation\n- **ğŸ“± MOBILE-RESPONSIVE NAV** - Navigation bar now fully responsive with tablet (768px) and mobile (480px) breakpoints, smaller buttons and text on mobile, emoji-only mode for tiny screens\n- **ğŸ¨ CSS CLASSES** - Converted inline navigation styles to proper CSS classes for better maintainability and responsive design\n- **ğŸŒ LANGUAGE TOGGLE** - Added EN/HU language switcher slider on website with localStorage persistence and full Hungarian translations\n- **ğŸ“‹ NAVIGATION MENU** - Added sticky navigation bar to both pages with links to Dashboard, Commands, Support Server, and Add Bot\n- **ğŸ”— QUICK LINKS & OWNER PROFILE** - Added support server, bot invite links, and developer profile section to both dashboard and help page\n- **ğŸ“– HELP PAGE** - Created shadowmod.net/help with full command documentation in futuristic theme, linked in !help, /help, /botinfo, and dashboard\n- **ğŸŒ CUSTOM DOMAIN** - Bot now uses shadowmod.net as custom domain for web dashboard\n- **ğŸŒ DASHBOARD PATH UPDATE** - Web dashboard moved to `/dashboard` path with automatic redirect from root for backward compatibility\n- **ğŸ”§ HELP COMMAND UPDATE** - Added anti-alt system section, standardized all commands with slash notation, reorganized categories for clarity\n- **ğŸ·ï¸ ROLE PREFIX SLASH COMMANDS** - Added /setprefix, /removeprefix, /viewprefixes for name automation (now 28 slash commands!)\n- **ğŸ“Š INFORMATION COMMANDS** - Added serverinfo, botinfo, userinfo (with badges), support, and webpage commands\n- **ğŸ”„ UPDATED HELP COMMAND** - Both !help and /help now show all commands organized by futuristic categories with neon cyan theme\n- **ğŸ¨ FUTURISTIC THEME** - Complete UI overhaul with cyberpunk neon colors (cyan, pink, purple, blue)\n- **ğŸŒ Live Web Stats Page** - Public dashboard showing real-time bot statistics at port 5000\n- **Updated tempmute** - Now uses Discord's native timeout feature (max 28 days) instead of role-based muting\n- **Enhanced AI Chat** - Bot now responds when mentioned anywhere (mention-only mode)\n- **Added verification system** - Button-based member verification with anti-alt protection\n- **Added /purge command** - Bulk message deletion (1-100 messages) with multilingual support\n- **Added AI Chat Assistant** - OpenAI-powered responses in designated channels with language support (en/hu)\n- **Added /ping command** - For Active Developer Badge maintenance\n- **Added multilingual meme generator** - Memes automatically generate in English or Hungarian based on server language\n- **Fixed role prefix duplication bug** - Role prefixes no longer duplicate when updated; auto-updates all members on prefix change\n- **Updated moderation commands** - All slash commands (/ban, /kick, /mute, /unmute, /warn) now accept both user mentions and user IDs\n- **Added multilanguage support** - English and Hungarian translations for all commands and messages\n- **Added language switcher** - !setlang and /setlang commands to change server language\n- **Added webhook logging system** - Real-time bot error and event monitoring via Discord webhooks\n- **Added dual prefix support** (! and /) - Helps users maintain Discord active developer badge\n- Added 16 slash commands with bilingual descriptions\n- Added poll system with interactive button voting\n- Added role management commands (create, delete, assign, remove)\n- Added giveaway system with automatic winner selection and reroll\n- Added name automation with role-based prefix system\n- Fixed giveaway unique custom_ids for concurrent giveaways\n- Fixed giveaway reroll to work with ended giveaways\n- Fixed timezone-aware datetime handling for anti-alt and moderation\n- Fixed per-guild muted role support\n- Initial bot implementation with all core features\n- Modular cog-based architecture for maintainability\n- Persistent button views for ticket system\n- Automatic temporary ban/mute expiration system\n- Integration with meme API for fun commands\n\n## User Preferences\nNone specified yet.\n","size_bytes":12343},"cogs/webhook_logging.py":{"content":"import discord\nfrom discord.ext import commands\nimport traceback\nimport sys\nfrom datetime import datetime, timezone\nimport aiohttp\nimport config\n\nclass WebhookLogging(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        cfg = config.load_config()\n        self.webhook_url = cfg.get('webhook_url')\n        \n    async def send_to_webhook(self, embed):\n        if not self.webhook_url:\n            return\n            \n        try:\n            async with aiohttp.ClientSession() as session:\n                webhook = discord.Webhook.from_url(self.webhook_url, session=session)\n                await webhook.send(embed=embed)\n        except Exception as e:\n            print(f\"Failed to send webhook: {e}\")\n    \n    @commands.Cog.listener()\n    async def on_command_error(self, ctx, error):\n        embed = discord.Embed(\n            title=\"âš ï¸ Command Error\",\n            color=discord.Color.red(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.add_field(name=\"Command\", value=f\"`{ctx.command}`\", inline=True)\n        embed.add_field(name=\"User\", value=f\"{ctx.author} ({ctx.author.id})\", inline=True)\n        embed.add_field(name=\"Channel\", value=f\"{ctx.channel.mention}\", inline=True)\n        \n        if isinstance(error, commands.MissingRequiredArgument):\n            embed.add_field(\n                name=\"Error Type\",\n                value=\"Missing Required Argument\",\n                inline=False\n            )\n            embed.add_field(\n                name=\"Details\",\n                value=f\"Missing: `{error.param.name}`\",\n                inline=False\n            )\n        elif isinstance(error, commands.MissingPermissions):\n            embed.add_field(\n                name=\"Error Type\",\n                value=\"Missing Permissions\",\n                inline=False\n            )\n            embed.add_field(\n                name=\"Details\",\n                value=f\"Required: {', '.join(error.missing_permissions)}\",\n                inline=False\n            )\n        elif isinstance(error, commands.CommandNotFound):\n            return\n        else:\n            embed.add_field(\n                name=\"Error Type\",\n                value=type(error).__name__,\n                inline=False\n            )\n            embed.add_field(\n                name=\"Details\",\n                value=f\"```py\\n{str(error)[:1000]}```\",\n                inline=False\n            )\n        \n        await self.send_to_webhook(embed)\n    \n    @commands.Cog.listener()\n    async def on_error(self, event, *args, **kwargs):\n        embed = discord.Embed(\n            title=\"âŒ Bot Error\",\n            color=discord.Color.dark_red(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.add_field(name=\"Event\", value=f\"`{event}`\", inline=False)\n        \n        exc_type, exc_value, exc_traceback = sys.exc_info()\n        if exc_type:\n            embed.add_field(\n                name=\"Error Type\",\n                value=exc_type.__name__,\n                inline=False\n            )\n            \n            tb_lines = traceback.format_exception(exc_type, exc_value, exc_traceback)\n            tb_text = ''.join(tb_lines)[-1500:]\n            \n            embed.add_field(\n                name=\"Traceback\",\n                value=f\"```py\\n{tb_text}```\",\n                inline=False\n            )\n        \n        await self.send_to_webhook(embed)\n    \n    @commands.Cog.listener()\n    async def on_ready(self):\n        embed = discord.Embed(\n            title=\"âœ… Bot Started\",\n            description=f\"Bot is online and ready!\",\n            color=discord.Color.green(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.add_field(name=\"Bot Name\", value=str(self.bot.user), inline=True)\n        embed.add_field(name=\"Bot ID\", value=str(self.bot.user.id), inline=True)\n        embed.add_field(name=\"Guilds\", value=str(len(self.bot.guilds)), inline=True)\n        \n        await self.send_to_webhook(embed)\n    \n    @commands.command(name='setwebhook')\n    @commands.has_permissions(administrator=True)\n    async def set_webhook(self, ctx, webhook_url: str):\n        self.webhook_url = webhook_url\n        config.update_config('webhook_url', webhook_url)\n        \n        embed = discord.Embed(\n            title=\"âœ… Webhook Set\",\n            description=\"Bot logging webhook has been configured!\",\n            color=discord.Color.green()\n        )\n        embed.add_field(\n            name=\"Test Message\",\n            value=\"If this appears in your webhook channel, logging is working!\",\n            inline=False\n        )\n        \n        await self.send_to_webhook(embed)\n        await ctx.send(\"âœ… Webhook logging configured! Check your webhook channel.\")\n    \n    @commands.command(name='testwebhook')\n    @commands.has_permissions(administrator=True)\n    async def test_webhook(self, ctx):\n        embed = discord.Embed(\n            title=\"ğŸ§ª Test Webhook\",\n            description=\"This is a test message from the bot!\",\n            color=discord.Color.blue(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.add_field(name=\"Tested by\", value=str(ctx.author), inline=True)\n        embed.add_field(name=\"Channel\", value=ctx.channel.mention, inline=True)\n        \n        await self.send_to_webhook(embed)\n        await ctx.send(\"âœ… Test webhook sent! Check your webhook channel.\")\n    \n    @commands.command(name='loginfo')\n    @commands.has_permissions(administrator=True)\n    async def log_info(self, ctx, *, message: str):\n        embed = discord.Embed(\n            title=\"â„¹ï¸ Info Log\",\n            description=message,\n            color=discord.Color.blue(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.add_field(name=\"Logged by\", value=str(ctx.author), inline=True)\n        \n        await self.send_to_webhook(embed)\n        await ctx.send(\"âœ… Info logged to webhook.\")\n\nasync def setup(bot):\n    await bot.add_cog(WebhookLogging(bot))\n","size_bytes":6031},"cogs/giveaways.py":{"content":"import discord\nfrom discord.ext import commands, tasks\nfrom discord.ui import Button, View\nfrom datetime import datetime, timezone, timedelta\nimport random\nimport config\n\nclass GiveawayView(View):\n    def __init__(self, giveaway_id, bot):\n        super().__init__(timeout=None)\n        self.giveaway_id = giveaway_id\n        self.bot = bot\n        \n        cfg = config.load_config()\n        giveaway_data = cfg.get('giveaways', {}).get(giveaway_id, {})\n        self.participants = set(giveaway_data.get('participants', []))\n        \n        self.children[0].custom_id = f'giveaway_enter_{giveaway_id}'\n    \n    @discord.ui.button(label='ğŸ‰ Enter Giveaway', style=discord.ButtonStyle.green)\n    async def enter_giveaway(self, interaction: discord.Interaction, button: Button):\n        user_id = interaction.user.id\n        \n        cfg = config.load_config()\n        \n        if user_id in self.participants:\n            self.participants.remove(user_id)\n            await interaction.response.send_message(\n                \"âŒ You have left the giveaway!\",\n                ephemeral=True\n            )\n        else:\n            self.participants.add(user_id)\n            await interaction.response.send_message(\n                \"âœ… You have entered the giveaway! Good luck!\",\n                ephemeral=True\n            )\n        \n        if 'giveaways' in cfg and self.giveaway_id in cfg['giveaways']:\n            cfg['giveaways'][self.giveaway_id]['participants'] = list(self.participants)\n            config.save_config(cfg)\n        \n        button.label = f\"ğŸ‰ Enter Giveaway ({len(self.participants)})\"\n        await interaction.message.edit(view=self)\n\nclass Giveaways(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.active_giveaways = {}\n        self.restore_giveaways()\n        self.check_giveaways.start()\n    \n    def restore_giveaways(self):\n        cfg = config.load_config()\n        giveaways = cfg.get('giveaways', {})\n        \n        for giveaway_id in giveaways.keys():\n            view = GiveawayView(giveaway_id, self.bot)\n            self.active_giveaways[giveaway_id] = view\n            self.bot.add_view(view)\n    \n    def cog_unload(self):\n        self.check_giveaways.cancel()\n    \n    @tasks.loop(seconds=30)\n    async def check_giveaways(self):\n        cfg = config.load_config()\n        current_time = datetime.now(timezone.utc).timestamp()\n        \n        giveaways = cfg.get('giveaways', {})\n        \n        for giveaway_id, data in list(giveaways.items()):\n            if current_time >= data['end_time']:\n                try:\n                    channel = self.bot.get_channel(int(data['channel_id']))\n                    message = await channel.fetch_message(int(data['message_id']))\n                    \n                    view = self.active_giveaways.get(giveaway_id)\n                    \n                    if view and len(view.participants) > 0:\n                        winners_count = min(data['winners'], len(view.participants))\n                        winners = random.sample(list(view.participants), winners_count)\n                        \n                        winner_mentions = \" \".join([f\"<@{w}>\" for w in winners])\n                        \n                        embed = discord.Embed(\n                            title=\"ğŸ‰ Giveaway Ended!\",\n                            description=f\"**Prize:** {data['prize']}\\n\\n**Winner(s):** {winner_mentions}\",\n                            color=discord.Color.gold(),\n                            timestamp=datetime.now(timezone.utc)\n                        )\n                        embed.set_footer(text=f\"Hosted by {data['host']}\")\n                        \n                        await message.edit(embed=embed, view=None)\n                        await channel.send(f\"ğŸŠ Congratulations {winner_mentions}! You won **{data['prize']}**!\")\n                    else:\n                        embed = discord.Embed(\n                            title=\"ğŸ‰ Giveaway Ended!\",\n                            description=f\"**Prize:** {data['prize']}\\n\\n**Winner:** No valid entries!\",\n                            color=0xFF006E,\n                            timestamp=datetime.now(timezone.utc)\n                        )\n                        embed.set_footer(text=f\"Hosted by {data['host']}\")\n                        await message.edit(embed=embed, view=None)\n                    \n                    if 'completed_giveaways' not in cfg:\n                        cfg['completed_giveaways'] = {}\n                    cfg['completed_giveaways'][giveaway_id] = giveaways[giveaway_id]\n                    \n                    del giveaways[giveaway_id]\n                    if giveaway_id in self.active_giveaways:\n                        del self.active_giveaways[giveaway_id]\n                except:\n                    pass\n        \n        cfg['giveaways'] = giveaways\n        config.save_config(cfg)\n    \n    @check_giveaways.before_loop\n    async def before_check_giveaways(self):\n        await self.bot.wait_until_ready()\n    \n    @commands.command(name='giveaway')\n    @commands.has_permissions(manage_guild=True)\n    async def start_giveaway(self, ctx, duration: str, winners: int, *, prize: str):\n        time_units = {'s': 1, 'm': 60, 'h': 3600, 'd': 86400}\n        \n        try:\n            time_amount = int(duration[:-1])\n            time_unit = duration[-1]\n        except:\n            await ctx.send(\"âŒ Invalid time format! Use: 10s, 5m, 2h, 1d\")\n            return\n        \n        if time_unit not in time_units:\n            await ctx.send(\"âŒ Invalid time format! Use: 10s, 5m, 2h, 1d\")\n            return\n        \n        if winners < 1:\n            await ctx.send(\"âŒ There must be at least 1 winner!\")\n            return\n        \n        seconds = time_amount * time_units[time_unit]\n        end_time = datetime.now(timezone.utc) + timedelta(seconds=seconds)\n        \n        embed = discord.Embed(\n            title=\"ğŸ‰ GIVEAWAY! ğŸ‰\",\n            description=f\"**Prize:** {prize}\\n**Winners:** {winners}\\n**Ends:** <t:{int(end_time.timestamp())}:R>\",\n            color=0x8B00FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        embed.set_footer(text=f\"Hosted by {ctx.author}\")\n        \n        giveaway_id = str(int(datetime.now(timezone.utc).timestamp()))\n        \n        cfg = config.load_config()\n        if 'giveaways' not in cfg:\n            cfg['giveaways'] = {}\n        \n        cfg['giveaways'][giveaway_id] = {\n            'prize': prize,\n            'winners': winners,\n            'end_time': end_time.timestamp(),\n            'channel_id': str(ctx.channel.id),\n            'message_id': '',\n            'host': str(ctx.author),\n            'participants': []\n        }\n        config.save_config(cfg)\n        \n        view = GiveawayView(giveaway_id, self.bot)\n        message = await ctx.send(embed=embed, view=view)\n        \n        self.active_giveaways[giveaway_id] = view\n        \n        cfg['giveaways'][giveaway_id]['message_id'] = str(message.id)\n        config.save_config(cfg)\n        \n        await ctx.message.delete()\n    \n    @commands.command(name='reroll')\n    @commands.has_permissions(manage_guild=True)\n    async def reroll_giveaway(self, ctx, message_id: int):\n        try:\n            message = await ctx.channel.fetch_message(message_id)\n            \n            if not message.embeds or \"giveaway\" not in message.embeds[0].title.lower():\n                await ctx.send(\"âŒ That's not a giveaway message!\")\n                return\n            \n            cfg = config.load_config()\n            giveaway_data = None\n            giveaway_id = None\n            \n            for gid, data in cfg.get('giveaways', {}).items():\n                if data.get('message_id') == str(message_id):\n                    giveaway_data = data\n                    giveaway_id = gid\n                    break\n            \n            if not giveaway_data:\n                for gid, data in cfg.get('completed_giveaways', {}).items():\n                    if data.get('message_id') == str(message_id):\n                        giveaway_data = data\n                        giveaway_id = gid\n                        break\n            \n            if not giveaway_data:\n                await ctx.send(\"âŒ Giveaway data not found!\")\n                return\n            \n            participants = giveaway_data.get('participants', [])\n            \n            if len(participants) == 0:\n                await ctx.send(\"âŒ No participants to reroll!\")\n                return\n            \n            new_winner_id = random.choice(participants)\n            new_winner = await self.bot.fetch_user(int(new_winner_id))\n            \n            embed = discord.Embed(\n                title=\"ğŸ‰ Giveaway Rerolled!\",\n                description=f\"**Prize:** {giveaway_data['prize']}\\n\\n**New Winner:** {new_winner.mention}\",\n                color=discord.Color.gold(),\n                timestamp=datetime.now(timezone.utc)\n            )\n            \n            await ctx.send(embed=embed)\n            await ctx.send(f\"ğŸŠ Congratulations {new_winner.mention}! You won **{giveaway_data['prize']}**!\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Error rerolling giveaway: {str(e)}\")\n\nasync def setup(bot):\n    await bot.add_cog(Giveaways(bot))\n","size_bytes":9331},"cogs/slash_commands.py":{"content":"import discord\nfrom discord import app_commands\nfrom discord.ext import commands\nimport config\nimport translations\nfrom datetime import datetime, timezone, timedelta\n\nclass SlashCommands(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @app_commands.command(name=\"help\", description=\"Show all bot commands / Ã–sszes parancs megjelenÃ­tÃ©se\")\n    async def slash_help(self, interaction: discord.Interaction):\n        guild_id = interaction.guild.id\n        \n        embed = discord.Embed(\n            title=translations.get_text(guild_id, 'help_title'),\n            description=translations.get_text(guild_id, 'help_description'),\n            color=0x00F3FF\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_info'),\n            value=translations.get_text(guild_id, 'help_info_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_security'),\n            value=translations.get_text(guild_id, 'help_security_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_antialt'),\n            value=translations.get_text(guild_id, 'help_antialt_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_tickets'),\n            value=translations.get_text(guild_id, 'help_tickets_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_moderation'),\n            value=translations.get_text(guild_id, 'help_moderation_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_music'),\n            value=translations.get_text(guild_id, 'help_music_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_games'),\n            value=translations.get_text(guild_id, 'help_games_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_engagement'),\n            value=translations.get_text(guild_id, 'help_engagement_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_nameauto'),\n            value=translations.get_text(guild_id, 'help_nameauto_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_config'),\n            value=translations.get_text(guild_id, 'help_config_desc'),\n            inline=False\n        )\n        \n        embed.add_field(\n            name=translations.get_text(guild_id, 'help_admin'),\n            value=translations.get_text(guild_id, 'help_admin_desc'),\n            inline=False\n        )\n        \n        embed.set_footer(text=\"âš¡ Made by MoonlightVFX | 48 Slash Commands Ready âš¡\")\n        \n        await interaction.response.send_message(embed=embed, ephemeral=True)\n    \n    @app_commands.command(name=\"ticket\", description=\"Create a ticket panel / Jegy panel lÃ©trehozÃ¡sa\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_ticket(self, interaction: discord.Interaction):\n        ticket_cog = self.bot.get_cog('Tickets')\n        if ticket_cog:\n            view = ticket_cog.TicketView()\n            self.bot.add_view(view)\n            \n            guild_id = interaction.guild.id\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'ticket_title'),\n                description=translations.get_text(guild_id, 'ticket_description'),\n                color=0x8B00FF\n            )\n            embed.add_field(\n                name=translations.get_text(guild_id, 'ticket_how_it_works'),\n                value=translations.get_text(guild_id, 'ticket_steps'),\n                inline=False\n            )\n            \n            await interaction.response.send_message(embed=embed, view=view)\n    \n    @app_commands.command(name=\"meme\", description=\"Get a random meme / VÃ©letlen meme lekÃ©rÃ©se\")\n    async def slash_meme(self, interaction: discord.Interaction):\n        import random\n        from urllib.parse import quote\n        import aiohttp\n        \n        guild_id = interaction.guild.id\n        lang = translations.get_guild_language(guild_id)\n        \n        fun_cog = self.bot.get_cog('Fun')\n        if not fun_cog:\n            await interaction.response.send_message(\"âŒ Meme feature unavailable\", ephemeral=True)\n            return\n        \n        templates = fun_cog.meme_templates_hu if lang == 'hu' else fun_cog.meme_templates_en\n        template_name, top_text, bottom_text = random.choice(templates)\n        \n        top_text_encoded = quote(top_text, safe='')\n        bottom_text_encoded = quote(bottom_text, safe='')\n        \n        meme_url = f\"https://api.memegen.link/images/{template_name}/{top_text_encoded}/{bottom_text_encoded}.png\"\n        \n        await interaction.response.defer()\n        \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.head(meme_url, timeout=aiohttp.ClientTimeout(total=5)) as response:\n                    if response.status != 200:\n                        raise Exception(\"Meme API unavailable\")\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'meme_title'),\n                color=discord.Color.random()\n            )\n            embed.set_image(url=meme_url)\n            embed.set_footer(text=translations.get_text(guild_id, 'generated_meme'))\n            \n            await interaction.followup.send(embed=embed)\n        except Exception:\n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'meme_title'),\n                description=f\"**{top_text}**\\n\\n*{bottom_text}*\",\n                color=discord.Color.random()\n            )\n            embed.set_footer(text=translations.get_text(guild_id, 'generated_meme'))\n            await interaction.followup.send(embed=embed)\n    \n    @app_commands.command(name=\"8ball\", description=\"Ask the magic 8-ball / KÃ©rdezd a varÃ¡zs labdÃ¡t\")\n    @app_commands.describe(question=\"Your question / A kÃ©rdÃ©sed\")\n    async def slash_8ball(self, interaction: discord.Interaction, question: str):\n        import random\n        \n        guild_id = interaction.guild.id\n        responses = translations.get_text(guild_id, '8ball_responses')\n        \n        embed = discord.Embed(\n            title=translations.get_text(guild_id, 'magic_8ball'),\n            color=discord.Color.purple()\n        )\n        embed.add_field(name=translations.get_text(guild_id, 'question'), value=question, inline=False)\n        embed.add_field(name=translations.get_text(guild_id, 'answer'), value=random.choice(responses), inline=False)\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"coinflip\", description=\"Flip a coin / PÃ©nzfeldobÃ¡s\")\n    async def slash_coinflip(self, interaction: discord.Interaction):\n        import random\n        \n        guild_id = interaction.guild.id\n        lang = translations.get_guild_language(guild_id)\n        \n        result_key = 'heads' if random.choice([True, False]) else 'tails'\n        result = translations.get_text(guild_id, result_key)\n        \n        embed = discord.Embed(\n            title=translations.get_text(guild_id, 'coin_flip'),\n            description=translations.get_text(guild_id, 'coin_result', result),\n            color=discord.Color.gold()\n        )\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"ban\", description=\"Ban a user / FelhasznÃ¡lÃ³ kitiltÃ¡sa\")\n    @app_commands.describe(user=\"User mention or ID / FelhasznÃ¡lÃ³ mention vagy ID\", reason=\"Reason / Indok\")\n    @app_commands.checks.has_permissions(ban_members=True)\n    async def slash_ban(self, interaction: discord.Interaction, user: str, reason: str = None):\n        guild_id = interaction.guild.id\n        \n        try:\n            # Try to convert string to user ID or extract from mention\n            user_id = None\n            if user.startswith('<@') and user.endswith('>'):\n                user_id = int(user.strip('<@!>'))\n            else:\n                try:\n                    user_id = int(user)\n                except ValueError:\n                    await interaction.response.send_message(translations.get_text(guild_id, 'invalid_user'), ephemeral=True)\n                    return\n            \n            # Fetch the user\n            try:\n                target_user = await interaction.guild.fetch_member(user_id)\n            except:\n                target_user = await self.bot.fetch_user(user_id)\n            \n            await interaction.guild.ban(target_user, reason=reason)\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'user_banned'),\n                description=translations.get_text(guild_id, 'user_banned_desc', target_user.mention),\n                color=0xFF006E\n            )\n            if reason:\n                embed.add_field(name=translations.get_text(guild_id, 'reason'), value=reason, inline=False)\n            embed.add_field(name=translations.get_text(guild_id, 'moderator'), value=interaction.user.mention, inline=True)\n            \n            await interaction.response.send_message(embed=embed)\n        except Exception as e:\n            await interaction.response.send_message(translations.get_text(guild_id, 'ban_failed', str(e)), ephemeral=True)\n    \n    @app_commands.command(name=\"kick\", description=\"Kick a user / FelhasznÃ¡lÃ³ kirÃºgÃ¡sa\")\n    @app_commands.describe(user=\"User mention or ID / FelhasznÃ¡lÃ³ mention vagy ID\", reason=\"Reason / Indok\")\n    @app_commands.checks.has_permissions(kick_members=True)\n    async def slash_kick(self, interaction: discord.Interaction, user: str, reason: str = None):\n        guild_id = interaction.guild.id\n        \n        try:\n            # Try to convert string to user ID or extract from mention\n            user_id = None\n            if user.startswith('<@') and user.endswith('>'):\n                user_id = int(user.strip('<@!>'))\n            else:\n                try:\n                    user_id = int(user)\n                except ValueError:\n                    await interaction.response.send_message(translations.get_text(guild_id, 'invalid_user'), ephemeral=True)\n                    return\n            \n            # Fetch the member\n            target_user = await interaction.guild.fetch_member(user_id)\n            \n            await target_user.kick(reason=reason)\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'user_kicked'),\n                description=translations.get_text(guild_id, 'user_kicked_desc', target_user.mention),\n                color=0xFF006E\n            )\n            if reason:\n                embed.add_field(name=translations.get_text(guild_id, 'reason'), value=reason, inline=False)\n            embed.add_field(name=translations.get_text(guild_id, 'moderator'), value=interaction.user.mention, inline=True)\n            \n            await interaction.response.send_message(embed=embed)\n        except Exception as e:\n            await interaction.response.send_message(translations.get_text(guild_id, 'kick_failed', str(e)), ephemeral=True)\n    \n    @app_commands.command(name=\"mute\", description=\"Mute a user / FelhasznÃ¡lÃ³ nÃ©mÃ­tÃ¡sa\")\n    @app_commands.describe(user=\"User mention or ID / FelhasznÃ¡lÃ³ mention vagy ID\")\n    @app_commands.checks.has_permissions(manage_roles=True)\n    async def slash_mute(self, interaction: discord.Interaction, user: str):\n        guild_id_int = interaction.guild.id\n        guild_id = str(guild_id_int)\n        \n        try:\n            # Try to convert string to user ID or extract from mention\n            user_id = None\n            if user.startswith('<@') and user.endswith('>'):\n                user_id = int(user.strip('<@!>'))\n            else:\n                try:\n                    user_id = int(user)\n                except ValueError:\n                    await interaction.response.send_message(translations.get_text(guild_id_int, 'invalid_user'), ephemeral=True)\n                    return\n            \n            # Fetch the member\n            target_user = await interaction.guild.fetch_member(user_id)\n            \n            cfg = config.load_config()\n            muted_role_id = cfg.get('muted_roles', {}).get(guild_id)\n            \n            if not muted_role_id:\n                muted_role = await interaction.guild.create_role(name=\"Muted\", color=discord.Color.dark_gray())\n                cfg.setdefault('muted_roles', {})[guild_id] = muted_role.id\n                config.save_config(cfg)\n                \n                for channel in interaction.guild.channels:\n                    await channel.set_permissions(muted_role, send_messages=False, speak=False)\n            else:\n                muted_role = interaction.guild.get_role(muted_role_id)\n            \n            await target_user.add_roles(muted_role)\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id_int, 'user_muted'),\n                description=translations.get_text(guild_id_int, 'user_muted_desc', target_user.mention),\n                color=discord.Color.dark_gray()\n            )\n            \n            await interaction.response.send_message(embed=embed)\n        except Exception as e:\n            await interaction.response.send_message(f\"âŒ Error: {str(e)}\", ephemeral=True)\n    \n    @app_commands.command(name=\"unmute\", description=\"Unmute a user / FelhasznÃ¡lÃ³ visszahangosÃ­tÃ¡sa\")\n    @app_commands.describe(user=\"User mention or ID / FelhasznÃ¡lÃ³ mention vagy ID\")\n    @app_commands.checks.has_permissions(manage_roles=True)\n    async def slash_unmute(self, interaction: discord.Interaction, user: str):\n        guild_id_int = interaction.guild.id\n        guild_id = str(guild_id_int)\n        \n        try:\n            # Try to convert string to user ID or extract from mention\n            user_id = None\n            if user.startswith('<@') and user.endswith('>'):\n                user_id = int(user.strip('<@!>'))\n            else:\n                try:\n                    user_id = int(user)\n                except ValueError:\n                    await interaction.response.send_message(translations.get_text(guild_id_int, 'invalid_user'), ephemeral=True)\n                    return\n            \n            # Fetch the member\n            target_user = await interaction.guild.fetch_member(user_id)\n            \n            cfg = config.load_config()\n            muted_role_id = cfg.get('muted_roles', {}).get(guild_id)\n            \n            if not muted_role_id:\n                await interaction.response.send_message(translations.get_text(guild_id_int, 'no_muted_role'), ephemeral=True)\n                return\n            \n            muted_role = interaction.guild.get_role(muted_role_id)\n            if muted_role in target_user.roles:\n                await target_user.remove_roles(muted_role)\n                \n                embed = discord.Embed(\n                    title=translations.get_text(guild_id_int, 'user_unmuted'),\n                    description=translations.get_text(guild_id_int, 'user_unmuted_desc', target_user.mention),\n                    color=0x00F3FF\n                )\n                \n                await interaction.response.send_message(embed=embed)\n            else:\n                await interaction.response.send_message(translations.get_text(guild_id_int, 'user_not_muted'), ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"âŒ Error: {str(e)}\", ephemeral=True)\n    \n    @app_commands.command(name=\"lock\", description=\"Lock the channel / Csatorna lezÃ¡rÃ¡sa\")\n    @app_commands.checks.has_permissions(manage_channels=True)\n    async def slash_lock(self, interaction: discord.Interaction):\n        guild_id = interaction.guild.id\n        \n        await interaction.channel.set_permissions(\n            interaction.guild.default_role,\n            send_messages=False\n        )\n        \n        embed = discord.Embed(\n            title=translations.get_text(guild_id, 'channel_locked'),\n            description=translations.get_text(guild_id, 'channel_locked_desc'),\n            color=0xFF006E\n        )\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"unlock\", description=\"Unlock the channel / Csatorna feloldÃ¡sa\")\n    @app_commands.checks.has_permissions(manage_channels=True)\n    async def slash_unlock(self, interaction: discord.Interaction):\n        guild_id = interaction.guild.id\n        \n        await interaction.channel.set_permissions(\n            interaction.guild.default_role,\n            send_messages=True\n        )\n        \n        embed = discord.Embed(\n            title=translations.get_text(guild_id, 'channel_unlocked'),\n            description=translations.get_text(guild_id, 'channel_unlocked_desc'),\n            color=0x00F3FF\n        )\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"warn\", description=\"Warn a user / FelhasznÃ¡lÃ³ figyelmeztetÃ©se\")\n    @app_commands.describe(user=\"User mention or ID / FelhasznÃ¡lÃ³ mention vagy ID\", reason=\"Reason / Indok\")\n    @app_commands.checks.has_permissions(manage_messages=True)\n    async def slash_warn(self, interaction: discord.Interaction, user: str, reason: str = None):\n        guild_id = interaction.guild.id\n        \n        try:\n            # Try to convert string to user ID or extract from mention\n            user_id_int = None\n            if user.startswith('<@') and user.endswith('>'):\n                user_id_int = int(user.strip('<@!>'))\n            else:\n                try:\n                    user_id_int = int(user)\n                except ValueError:\n                    await interaction.response.send_message(translations.get_text(guild_id, 'invalid_user'), ephemeral=True)\n                    return\n            \n            # Fetch the member\n            target_user = await interaction.guild.fetch_member(user_id_int)\n            \n            cfg = config.load_config()\n            warnings = cfg.get('warnings', {})\n            user_id = str(target_user.id)\n            \n            if user_id not in warnings:\n                warnings[user_id] = []\n            \n            warnings[user_id].append({\n                'reason': reason or translations.get_text(guild_id, 'no_reason_provided'),\n                'moderator': str(interaction.user),\n                'timestamp': datetime.now(timezone.utc).isoformat()\n            })\n            \n            cfg['warnings'] = warnings\n            config.save_config(cfg)\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'user_warned'),\n                description=translations.get_text(guild_id, 'user_warned_desc', target_user.mention),\n                color=discord.Color.yellow()\n            )\n            embed.add_field(name=translations.get_text(guild_id, 'reason'), value=reason or translations.get_text(guild_id, 'no_reason_provided'), inline=False)\n            embed.add_field(name=translations.get_text(guild_id, 'total_warnings'), value=str(len(warnings[user_id])), inline=True)\n            \n            await interaction.response.send_message(embed=embed)\n        except Exception as e:\n            await interaction.response.send_message(f\"âŒ Error: {str(e)}\", ephemeral=True)\n    \n    @app_commands.command(name=\"setlog\", description=\"Set log channel / NaplÃ³ csatorna beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(channel=\"The channel / A csatorna\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_setlog(self, interaction: discord.Interaction, channel: discord.TextChannel):\n        guild_id = interaction.guild.id\n        config.update_config('log_channel_id', channel.id)\n        \n        embed = discord.Embed(\n            title=translations.get_text(guild_id, 'log_channel_set'),\n            description=translations.get_text(guild_id, 'log_channel_desc', channel.mention),\n            color=0x00F3FF\n        )\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"setwebhook\", description=\"Set webhook for logging / Webhook beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(webhook_url=\"Discord webhook URL / Discord webhook URL\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_setwebhook(self, interaction: discord.Interaction, webhook_url: str):\n        guild_id = interaction.guild.id\n        webhook_cog = self.bot.get_cog('WebhookLogging')\n        if webhook_cog:\n            webhook_cog.webhook_url = webhook_url\n            config.update_config('webhook_url', webhook_url)\n            \n            test_embed = discord.Embed(\n                title=translations.get_text(guild_id, 'webhook_set'),\n                description=translations.get_text(guild_id, 'webhook_set_desc'),\n                color=0x00F3FF,\n                timestamp=datetime.now(timezone.utc)\n            )\n            test_embed.add_field(\n                name=translations.get_text(guild_id, 'test_message'),\n                value=translations.get_text(guild_id, 'webhook_working'),\n                inline=False\n            )\n            \n            await webhook_cog.send_to_webhook(test_embed)\n            await interaction.response.send_message(translations.get_text(guild_id, 'webhook_configured'))\n    \n    @app_commands.command(name=\"testwebhook\", description=\"Test webhook / Webhook tesztelÃ©se\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_testwebhook(self, interaction: discord.Interaction):\n        guild_id = interaction.guild.id\n        webhook_cog = self.bot.get_cog('WebhookLogging')\n        if webhook_cog:\n            test_embed = discord.Embed(\n                title=translations.get_text(guild_id, 'webhook_test'),\n                description=translations.get_text(guild_id, 'webhook_test_desc'),\n                color=0x8B00FF,\n                timestamp=datetime.now(timezone.utc)\n            )\n            test_embed.add_field(name=translations.get_text(guild_id, 'tested_by'), value=str(interaction.user), inline=True)\n            test_embed.add_field(name=translations.get_text(guild_id, 'channel'), value=interaction.channel.mention, inline=True)\n            \n            await webhook_cog.send_to_webhook(test_embed)\n            await interaction.response.send_message(translations.get_text(guild_id, 'test_webhook_sent'))\n    \n    @app_commands.command(name=\"ping\", description=\"Check bot latency / Bot kÃ©sleltetÃ©s ellenÅ‘rzÃ©se\")\n    async def slash_ping(self, interaction: discord.Interaction):\n        latency = round(self.bot.latency * 1000)\n        \n        embed = discord.Embed(\n            title=\"ğŸ“ Pong!\",\n            description=f\"Bot latency: **{latency}ms**\",\n            color=0x00F3FF\n        )\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"purge\", description=\"Delete multiple messages / TÃ¶bb Ã¼zenet tÃ¶rlÃ©se\")\n    @app_commands.describe(amount=\"Number of messages to delete (1-100) / TÃ¶rÃ¶lni kÃ­vÃ¡nt Ã¼zenetek szÃ¡ma\")\n    @app_commands.checks.has_permissions(manage_messages=True)\n    async def slash_purge(self, interaction: discord.Interaction, amount: int):\n        import asyncio\n        \n        guild_id = interaction.guild.id\n        \n        if amount < 1 or amount > 100:\n            await interaction.response.send_message(\n                translations.get_text(guild_id, 'purge_invalid'),\n                ephemeral=True\n            )\n            return\n        \n        await interaction.response.defer(ephemeral=True)\n        \n        try:\n            deleted = await interaction.channel.purge(limit=amount)\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'messages_purged'),\n                description=translations.get_text(guild_id, 'messages_purged_desc', len(deleted)),\n                color=0xFF006E,\n                timestamp=datetime.now(timezone.utc)\n            )\n            embed.add_field(\n                name=translations.get_text(guild_id, 'moderator'),\n                value=interaction.user.mention\n            )\n            \n            await interaction.followup.send(embed=embed, ephemeral=True)\n            \n            mod_cog = self.bot.get_cog('Moderation')\n            if mod_cog:\n                await mod_cog.send_log(embed)\n                \n        except discord.Forbidden:\n            await interaction.followup.send(\n                \"âŒ I don't have permission to delete messages!\",\n                ephemeral=True\n            )\n        except Exception as e:\n            await interaction.followup.send(\n                f\"âŒ An error occurred: {str(e)}\",\n                ephemeral=True\n            )\n\n    @app_commands.command(name=\"serverinfo\", description=\"Show server information / Szerver informÃ¡ciÃ³k megjelenÃ­tÃ©se\")\n    async def slash_serverinfo(self, interaction: discord.Interaction):\n        info_cog = self.bot.get_cog('Info')\n        if info_cog:\n            ctx = await self.bot.get_context(interaction)\n            ctx.author = interaction.user\n            ctx.guild = interaction.guild\n            ctx.send = interaction.response.send_message\n            await info_cog.serverinfo(ctx)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"botinfo\", description=\"Show bot information / Bot informÃ¡ciÃ³k megjelenÃ­tÃ©se\")\n    async def slash_botinfo(self, interaction: discord.Interaction):\n        info_cog = self.bot.get_cog('Info')\n        if info_cog:\n            ctx = await self.bot.get_context(interaction)\n            ctx.author = interaction.user\n            ctx.guild = interaction.guild\n            ctx.send = interaction.response.send_message\n            await info_cog.botinfo(ctx)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"userinfo\", description=\"Show user information / FelhasznÃ¡lÃ³ informÃ¡ciÃ³k megjelenÃ­tÃ©se\")\n    async def slash_userinfo(self, interaction: discord.Interaction, member: discord.Member = None):\n        info_cog = self.bot.get_cog('Info')\n        if info_cog:\n            ctx = await self.bot.get_context(interaction)\n            ctx.author = interaction.user\n            ctx.guild = interaction.guild\n            ctx.send = interaction.response.send_message\n            await info_cog.userinfo(ctx, member)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"support\", description=\"Get support server invite / Support szerver meghÃ­vÃ³\")\n    async def slash_support(self, interaction: discord.Interaction):\n        info_cog = self.bot.get_cog('Info')\n        if info_cog:\n            ctx = await self.bot.get_context(interaction)\n            ctx.author = interaction.user\n            ctx.send = interaction.response.send_message\n            await info_cog.support(ctx)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"webpage\", description=\"Get web dashboard link / Web irÃ¡nyÃ­tÃ³pult link\")\n    async def slash_webpage(self, interaction: discord.Interaction):\n        info_cog = self.bot.get_cog('Info')\n        if info_cog:\n            ctx = await self.bot.get_context(interaction)\n            ctx.author = interaction.user\n            ctx.send = interaction.response.send_message\n            await info_cog.webpage(ctx)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"setprefix\", description=\"Set role prefix for nicknames / Szerep prefix beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(role=\"The role to set prefix for / Szerep\", prefix=\"Prefix text (max 10 chars) / Prefix szÃ¶veg\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_setprefix(self, interaction: discord.Interaction, role: discord.Role, prefix: str):\n        nameauto_cog = self.bot.get_cog('NameAutomation')\n        if nameauto_cog:\n            if len(prefix) > 10:\n                await interaction.response.send_message(\"âŒ Prefix must be 10 characters or less!\", ephemeral=True)\n                return\n            \n            import config as cfg_module\n            cfg = cfg_module.load_config()\n            if 'role_prefixes' not in cfg:\n                cfg['role_prefixes'] = {}\n            \n            cfg['role_prefixes'][str(role.id)] = prefix\n            cfg_module.save_config(cfg)\n            \n            embed = discord.Embed(\n                title=\"âœ… Prefix Set\",\n                description=f\"Members with {role.mention} will have `{prefix}` prefix in their nickname!\",\n                color=0x00F3FF\n            )\n            embed.add_field(name=\"Example\", value=f\"{prefix} Username\", inline=False)\n            \n            await interaction.response.send_message(embed=embed)\n            \n            await interaction.followup.send(\"ğŸ”„ Updating member nicknames...\", ephemeral=True)\n            count = 0\n            for member in interaction.guild.members:\n                if role in member.roles:\n                    await nameauto_cog.update_member_nickname(member)\n                    count += 1\n            \n            embed.add_field(name=\"Updated\", value=f\"{count} members updated!\", inline=False)\n            await interaction.edit_original_response(embed=embed)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"removeprefix\", description=\"Remove role prefix / Szerep prefix eltÃ¡volÃ­tÃ¡sa\")\n    @app_commands.describe(role=\"The role to remove prefix from / Szerep\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_removeprefix(self, interaction: discord.Interaction, role: discord.Role):\n        nameauto_cog = self.bot.get_cog('NameAutomation')\n        if nameauto_cog:\n            import config as cfg_module\n            cfg = cfg_module.load_config()\n            role_prefixes = cfg.get('role_prefixes', {})\n            \n            if str(role.id) not in role_prefixes:\n                await interaction.response.send_message(f\"âŒ {role.mention} doesn't have a prefix set!\", ephemeral=True)\n                return\n            \n            del cfg['role_prefixes'][str(role.id)]\n            cfg_module.save_config(cfg)\n            \n            embed = discord.Embed(\n                title=\"âœ… Prefix Removed\",\n                description=f\"Prefix removed from {role.mention}\",\n                color=0x00F3FF\n            )\n            \n            await interaction.response.send_message(embed=embed)\n            \n            await interaction.followup.send(\"ğŸ”„ Updating member nicknames...\", ephemeral=True)\n            count = 0\n            for member in interaction.guild.members:\n                if role in member.roles:\n                    await nameauto_cog.update_member_nickname(member)\n                    count += 1\n            \n            embed.add_field(name=\"Updated\", value=f\"{count} members updated!\", inline=False)\n            await interaction.edit_original_response(embed=embed)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"viewprefixes\", description=\"View all role prefixes / Ã–sszes szerep prefix megtekintÃ©se\")\n    async def slash_viewprefixes(self, interaction: discord.Interaction):\n        import config as cfg_module\n        cfg = cfg_module.load_config()\n        role_prefixes = cfg.get('role_prefixes', {})\n        \n        if not role_prefixes:\n            await interaction.response.send_message(\"âŒ No role prefixes configured!\", ephemeral=True)\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸ“‹ Role Prefixes\",\n            description=\"Current role prefix configuration:\",\n            color=0x8B00FF\n        )\n        \n        for role_id, prefix in role_prefixes.items():\n            role = interaction.guild.get_role(int(role_id))\n            if role:\n                embed.add_field(\n                    name=role.name,\n                    value=f\"Prefix: `{prefix}`\",\n                    inline=False\n                )\n        \n        await interaction.response.send_message(embed=embed, ephemeral=True)\n    \n    @app_commands.command(name=\"setaltage\", description=\"Set minimum account age / MinimÃ¡lis fiÃ³k kor beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(days=\"Minimum account age in days / MinimÃ¡lis fiÃ³k kor napokban\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_setaltage(self, interaction: discord.Interaction, days: int):\n        if days < 0:\n            await interaction.response.send_message(\"âŒ Days must be a positive number!\", ephemeral=True)\n            return\n        \n        import config as cfg_module\n        cfg_module.update_config('min_account_age_days', days)\n        \n        embed = discord.Embed(\n            title=\"âœ… Anti-Alt Configuration Updated\",\n            description=f\"Minimum account age set to **{days} days**\",\n            color=0x00F3FF\n        )\n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"tempmute\", description=\"Temporarily mute a user / FelhasznÃ¡lÃ³ ideiglenes nÃ©mÃ­tÃ¡sa\")\n    @app_commands.describe(\n        user=\"User to mute / NÃ©mÃ­tandÃ³ felhasznÃ¡lÃ³\",\n        duration=\"Duration (e.g., 1h, 30m, 1d) / IdÅ‘tartam\"\n    )\n    @app_commands.checks.has_permissions(moderate_members=True)\n    async def slash_tempmute(self, interaction: discord.Interaction, user: discord.Member, duration: str):\n        moderation_cog = self.bot.get_cog('Moderation')\n        if moderation_cog:\n            try:\n                time_dict = moderation_cog.parse_time(duration)\n                delta = timedelta(**time_dict)\n                \n                if delta.total_seconds() > 2419200:\n                    await interaction.response.send_message(\"âŒ Maximum timeout duration is 28 days!\", ephemeral=True)\n                    return\n                \n                await user.timeout(delta, reason=f\"Timed out by {interaction.user}\")\n                \n                embed = discord.Embed(\n                    title=\"ğŸ”‡ User Timed Out\",\n                    description=f\"{user.mention} has been timed out\",\n                    color=0xFF006E\n                )\n                embed.add_field(name=\"Duration\", value=duration, inline=True)\n                embed.add_field(name=\"Moderator\", value=interaction.user.mention, inline=True)\n                \n                await interaction.response.send_message(embed=embed)\n            except ValueError as e:\n                await interaction.response.send_message(f\"âŒ Invalid time format! Use: 1h, 30m, 1d, etc.\", ephemeral=True)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"dice\", description=\"Roll a dice / KockadobÃ¡s\")\n    @app_commands.describe(sides=\"Number of sides (default: 6) / Oldalak szÃ¡ma\")\n    async def slash_dice(self, interaction: discord.Interaction, sides: int = 6):\n        fun_cog = self.bot.get_cog('Fun')\n        if fun_cog:\n            await interaction.response.defer()\n            \n            import random\n            result = random.randint(1, sides)\n            \n            embed = discord.Embed(\n                title=\"ğŸ² Dice Roll\",\n                description=f\"You rolled a **{result}** on a {sides}-sided dice!\",\n                color=0x8B00FF\n            )\n            embed.set_footer(text=f\"Rolled by {interaction.user.display_name}\")\n            \n            await interaction.followup.send(embed=embed)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"rps\", description=\"Play Rock-Paper-Scissors / KÅ‘-PapÃ­r-OllÃ³ jÃ¡tÃ©k\")\n    @app_commands.describe(choice=\"Your choice / VÃ¡lasztÃ¡sod\")\n    @app_commands.choices(choice=[\n        app_commands.Choice(name=\"ğŸª¨ Rock / KÅ‘\", value=\"rock\"),\n        app_commands.Choice(name=\"ğŸ“„ Paper / PapÃ­r\", value=\"paper\"),\n        app_commands.Choice(name=\"âœ‚ï¸ Scissors / OllÃ³\", value=\"scissors\")\n    ])\n    async def slash_rps(self, interaction: discord.Interaction, choice: str):\n        games_cog = self.bot.get_cog('Games')\n        if games_cog:\n            import random\n            \n            choices = ['rock', 'paper', 'scissors']\n            bot_choice = random.choice(choices)\n            \n            emoji_map = {'rock': 'ğŸª¨', 'paper': 'ğŸ“„', 'scissors': 'âœ‚ï¸'}\n            \n            if choice == bot_choice:\n                result = \"It's a tie!\"\n                color = 0x8B00FF\n            elif (choice == 'rock' and bot_choice == 'scissors') or \\\n                 (choice == 'paper' and bot_choice == 'rock') or \\\n                 (choice == 'scissors' and bot_choice == 'paper'):\n                result = \"You win!\"\n                color = 0x00F3FF\n            else:\n                result = \"I win!\"\n                color = 0xFF006E\n            \n            embed = discord.Embed(\n                title=\"ğŸ® Rock-Paper-Scissors\",\n                description=f\"**You:** {emoji_map[choice]}\\n**Bot:** {emoji_map[bot_choice]}\\n\\n**{result}**\",\n                color=color\n            )\n            \n            await interaction.response.send_message(embed=embed)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"tictactoe\", description=\"Play Tic-Tac-Toe / AmÅ‘ba jÃ¡tÃ©k\")\n    @app_commands.describe(opponent=\"Player to challenge / KihÃ­vandÃ³ jÃ¡tÃ©kos\")\n    async def slash_tictactoe(self, interaction: discord.Interaction, opponent: discord.Member):\n        games_cog = self.bot.get_cog('Games')\n        if games_cog:\n            if opponent == interaction.user:\n                await interaction.response.send_message(\"âŒ You can't play against yourself!\", ephemeral=True)\n                return\n            \n            if opponent.bot:\n                await interaction.response.send_message(\"âŒ You can't play against a bot!\", ephemeral=True)\n                return\n            \n            view = games_cog.TicTacToeView(interaction.user, opponent)\n            \n            embed = discord.Embed(\n                title=\"â­• Tic-Tac-Toe\",\n                description=f\"{interaction.user.mention} vs {opponent.mention}\\n\\n{interaction.user.mention}'s turn (â­•)\",\n                color=0x8B00FF\n            )\n            \n            await interaction.response.send_message(embed=embed, view=view)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"poll\", description=\"Create a poll / SzavazÃ¡s lÃ©trehozÃ¡sa\")\n    @app_commands.describe(\n        question=\"Poll question / KÃ©rdÃ©s\",\n        option1=\"First option / ElsÅ‘ lehetÅ‘sÃ©g\",\n        option2=\"Second option / MÃ¡sodik lehetÅ‘sÃ©g\",\n        option3=\"Third option (optional) / Harmadik lehetÅ‘sÃ©g\",\n        option4=\"Fourth option (optional) / Negyedik lehetÅ‘sÃ©g\"\n    )\n    async def slash_poll(self, interaction: discord.Interaction, question: str, option1: str, option2: str, \n                        option3: str = None, option4: str = None):\n        polls_cog = self.bot.get_cog('Polls')\n        if polls_cog:\n            options = [option1, option2]\n            if option3:\n                options.append(option3)\n            if option4:\n                options.append(option4)\n            \n            view = polls_cog.PollView(options)\n            \n            embed = discord.Embed(\n                title=\"ğŸ“Š \" + question,\n                description=\"Click the buttons below to vote!\",\n                color=0x8B00FF\n            )\n            \n            for i, option in enumerate(options, 1):\n                embed.add_field(name=f\"Option {i}\", value=option, inline=False)\n            \n            embed.set_footer(text=f\"Poll by {interaction.user.display_name}\")\n            \n            await interaction.response.send_message(embed=embed, view=view)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"giveaway\", description=\"Create a giveaway / NyeremÃ©nyjÃ¡tÃ©k lÃ©trehozÃ¡sa\")\n    @app_commands.describe(\n        prize=\"Prize to give away / NyeremÃ©ny\",\n        duration=\"Duration (e.g., 1h, 1d) / IdÅ‘tartam\",\n        winners=\"Number of winners / Nyertesek szÃ¡ma\"\n    )\n    @app_commands.checks.has_permissions(manage_guild=True)\n    async def slash_giveaway(self, interaction: discord.Interaction, prize: str, duration: str, winners: int = 1):\n        giveaway_cog = self.bot.get_cog('Giveaways')\n        if giveaway_cog:\n            try:\n                time_dict = giveaway_cog.parse_time(duration)\n                end_time = datetime.now(timezone.utc) + timedelta(**time_dict)\n                \n                embed = discord.Embed(\n                    title=\"ğŸ GIVEAWAY\",\n                    description=f\"**Prize:** {prize}\\n**Winners:** {winners}\\n**Ends:** <t:{int(end_time.timestamp())}:R>\",\n                    color=0xFF006E\n                )\n                embed.set_footer(text=f\"Hosted by {interaction.user.display_name}\")\n                \n                from datetime import datetime, timezone\n                giveaway_id = f\"giveaway_{interaction.channel.id}_{int(datetime.now(timezone.utc).timestamp())}\"\n                view = giveaway_cog.GiveawayView(end_time, winners, prize, giveaway_id)\n                \n                await interaction.response.send_message(embed=embed, view=view)\n                \n                message = await interaction.original_response()\n                self.bot.loop.create_task(giveaway_cog.end_giveaway(message, end_time, winners, prize))\n            except ValueError:\n                await interaction.response.send_message(\"âŒ Invalid time format! Use: 1h, 30m, 1d, etc.\", ephemeral=True)\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"createrole\", description=\"Create a new role / Ãšj szerep lÃ©trehozÃ¡sa\")\n    @app_commands.describe(\n        name=\"Role name / Szerep neve\",\n        color=\"Hex color (e.g., #FF0000) / SzÃ­n\"\n    )\n    @app_commands.checks.has_permissions(manage_roles=True)\n    async def slash_createrole(self, interaction: discord.Interaction, name: str, color: str = None):\n        try:\n            role_color = discord.Color.default()\n            if color:\n                color = color.lstrip('#')\n                role_color = discord.Color(int(color, 16))\n            \n            role = await interaction.guild.create_role(name=name, color=role_color)\n            \n            embed = discord.Embed(\n                title=\"âœ… Role Created\",\n                description=f\"Role {role.mention} has been created!\",\n                color=0x00F3FF\n            )\n            \n            await interaction.response.send_message(embed=embed)\n        except ValueError:\n            await interaction.response.send_message(\"âŒ Invalid color format! Use hex format like #FF0000\", ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"âŒ Error creating role: {str(e)}\", ephemeral=True)\n    \n    @app_commands.command(name=\"closeticket\", description=\"Close a ticket / Jegy lezÃ¡rÃ¡sa\")\n    @app_commands.checks.has_permissions(manage_channels=True)\n    async def slash_closeticket(self, interaction: discord.Interaction):\n        ticket_cog = self.bot.get_cog('Tickets')\n        if ticket_cog:\n            if not interaction.channel.name.startswith('ticket-'):\n                await interaction.response.send_message(\"âŒ This command can only be used in ticket channels!\", ephemeral=True)\n                return\n            \n            embed = discord.Embed(\n                title=\"ğŸ« Ticket Closed\",\n                description=\"This ticket has been closed.\",\n                color=0xFF006E\n            )\n            \n            await interaction.response.send_message(embed=embed)\n            await interaction.channel.delete(reason=\"Ticket closed\")\n        else:\n            await interaction.response.send_message(\"âŒ Feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"play\", description=\"Play music from YouTube, Spotify, or SoundCloud / Zene lejÃ¡tszÃ¡sa\")\n    @app_commands.describe(query=\"Song name or URL / Dal neve vagy URL\")\n    async def slash_play(self, interaction: discord.Interaction, query: str):\n        music_cog = self.bot.get_cog('Music')\n        if music_cog:\n            await interaction.response.defer()\n            \n            class FakeContext:\n                def __init__(self, interaction):\n                    self.author = interaction.user\n                    self.guild = interaction.guild\n                    self.channel = interaction.channel\n                    self.bot = interaction.client\n                    self.voice_client = interaction.guild.voice_client\n                    self._interaction = interaction\n                \n                async def send(self, *args, **kwargs):\n                    try:\n                        await self._interaction.followup.send(*args, **kwargs)\n                    except:\n                        await self._interaction.channel.send(*args, **kwargs)\n            \n            ctx = FakeContext(interaction)\n            await music_cog.play(ctx, query=query)\n        else:\n            await interaction.response.send_message(\"âŒ Music feature unavailable\", ephemeral=True)\n    \n    @app_commands.command(name=\"pause\", description=\"Pause the current playback / LejÃ¡tszÃ¡s szÃ¼neteltetÃ©se\")\n    async def slash_pause(self, interaction: discord.Interaction):\n        import wavelink\n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc or not vc.playing:\n            await interaction.response.send_message(\"âŒ Nothing is playing\", ephemeral=True)\n            return\n        \n        await vc.pause(True)\n        await interaction.response.send_message(\"â¸ï¸ Paused playback\", ephemeral=True)\n    \n    @app_commands.command(name=\"resume\", description=\"Resume paused playback / LejÃ¡tszÃ¡s folytatÃ¡sa\")\n    async def slash_resume(self, interaction: discord.Interaction):\n        import wavelink\n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc or not vc.paused:\n            await interaction.response.send_message(\"âŒ Nothing is paused\", ephemeral=True)\n            return\n        \n        await vc.pause(False)\n        await interaction.response.send_message(\"â–¶ï¸ Resumed playback\", ephemeral=True)\n    \n    @app_commands.command(name=\"skip\", description=\"Skip to the next song / KÃ¶vetkezÅ‘ dal\")\n    async def slash_skip(self, interaction: discord.Interaction):\n        import wavelink\n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc or not vc.playing:\n            await interaction.response.send_message(\"âŒ Nothing is playing\", ephemeral=True)\n            return\n        \n        await vc.skip(force=True)\n        await interaction.response.send_message(\"â­ï¸ Skipped to next song\", ephemeral=True)\n    \n    @app_commands.command(name=\"stop\", description=\"Stop playback and disconnect / LejÃ¡tszÃ¡s leÃ¡llÃ­tÃ¡sa\")\n    async def slash_stop(self, interaction: discord.Interaction):\n        import wavelink\n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc:\n            await interaction.response.send_message(\"âŒ Not connected to voice\", ephemeral=True)\n            return\n        \n        await vc.disconnect()\n        await interaction.response.send_message(\"â¹ï¸ Stopped playback and disconnected\", ephemeral=True)\n    \n    @app_commands.command(name=\"queue\", description=\"Display the music queue / Zene sor megjelenÃ­tÃ©se\")\n    async def slash_queue(self, interaction: discord.Interaction):\n        import wavelink\n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc:\n            await interaction.response.send_message(\"âŒ Not connected to voice\", ephemeral=True)\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸµ Music Queue\",\n            color=0x8B00FF\n        )\n        \n        if vc.current:\n            embed.add_field(\n                name=\"Now Playing\",\n                value=f\"ğŸ¶ **{vc.current.title}**\\n`{vc.current.author}`\",\n                inline=False\n            )\n        \n        if vc.queue:\n            queue_list = []\n            for i, track in enumerate(vc.queue[:10], 1):\n                queue_list.append(f\"{i}. **{track.title}** - `{track.author}`\")\n            \n            embed.add_field(\n                name=f\"Up Next ({vc.queue.count} songs)\",\n                value=\"\\n\".join(queue_list),\n                inline=False\n            )\n        else:\n            if not vc.current:\n                embed.description = \"Queue is empty\"\n        \n        if vc.queue.mode == wavelink.QueueMode.loop:\n            embed.set_footer(text=\"ğŸ” Loop: ON\")\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"nowplaying\", description=\"Show currently playing track / Jelenlegi dal megjelenÃ­tÃ©se\")\n    async def slash_nowplaying(self, interaction: discord.Interaction):\n        import wavelink\n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc or not vc.current:\n            await interaction.response.send_message(\"âŒ Nothing is playing\", ephemeral=True)\n            return\n        \n        track = vc.current\n        \n        position = vc.position\n        duration = track.length\n        \n        progress_bar_length = 20\n        progress = int((position / duration) * progress_bar_length) if duration > 0 else 0\n        bar = \"â–ˆ\" * progress + \"â–‘\" * (progress_bar_length - progress)\n        \n        position_str = f\"{int(position // 60)}:{int(position % 60):02d}\"\n        duration_str = f\"{int(duration // 60)}:{int(duration % 60):02d}\"\n        \n        embed = discord.Embed(\n            title=\"ğŸµ Now Playing\",\n            description=f\"**{track.title}**\\n`{track.author}`\",\n            color=0x00F3FF\n        )\n        \n        embed.add_field(\n            name=\"Progress\",\n            value=f\"`{position_str}` {bar} `{duration_str}`\",\n            inline=False\n        )\n        \n        if hasattr(track, 'artwork') and track.artwork:\n            embed.set_thumbnail(url=track.artwork)\n        \n        if vc.queue.mode == wavelink.QueueMode.loop:\n            embed.set_footer(text=\"ğŸ” Loop: ON\")\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"loop\", description=\"Toggle loop mode / IsmÃ©tlÃ©s be/ki\")\n    async def slash_loop(self, interaction: discord.Interaction):\n        import wavelink\n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc:\n            await interaction.response.send_message(\"âŒ Not connected to voice\", ephemeral=True)\n            return\n        \n        if vc.queue.mode == wavelink.QueueMode.loop:\n            vc.queue.mode = wavelink.QueueMode.normal\n            status = \"disabled\"\n            emoji = \"â¡ï¸\"\n        else:\n            vc.queue.mode = wavelink.QueueMode.loop\n            status = \"enabled\"\n            emoji = \"ğŸ”\"\n        \n        await interaction.response.send_message(f\"{emoji} Loop mode {status}\", ephemeral=True)\n    \n    @app_commands.command(name=\"volume\", description=\"Adjust playback volume / HangerÅ‘ beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(volume=\"Volume level (0-100) / HangerÅ‘ szint (0-100)\")\n    async def slash_volume(self, interaction: discord.Interaction, volume: int):\n        import wavelink\n        \n        if volume < 0 or volume > 100:\n            await interaction.response.send_message(\"âŒ Volume must be between 0 and 100\", ephemeral=True)\n            return\n        \n        vc: wavelink.Player = interaction.guild.voice_client\n        \n        if not vc:\n            await interaction.response.send_message(\"âŒ Not connected to voice\", ephemeral=True)\n            return\n        \n        await vc.set_volume(volume)\n        await interaction.response.send_message(f\"ğŸ”Š Volume set to {volume}%\", ephemeral=True)\n    \n    @app_commands.command(name=\"servers\", description=\"List all servers the bot is in (Owner Only) / Bot Ã¡ltal hasznÃ¡lt szerverek listÃ¡ja\")\n    async def slash_servers(self, interaction: discord.Interaction):\n        if not await self.bot.is_owner(interaction.user):\n            await interaction.response.send_message(translations.get_text(interaction.guild.id, 'owner_only'), ephemeral=True)\n            return\n        \n        guild_id = interaction.guild.id if interaction.guild else None\n        \n        embed = discord.Embed(\n            title=translations.get_text(guild_id, 'servers_title'),\n            description=translations.get_text(guild_id, 'servers_description', len(self.bot.guilds)),\n            color=0x00ffff\n        )\n        \n        server_list = []\n        for guild in self.bot.guilds:\n            server_list.append(f\"**{guild.name}**\\n`ID: {guild.id}`\")\n        \n        if server_list:\n            chunks = [server_list[i:i+10] for i in range(0, len(server_list), 10)]\n            for i, chunk in enumerate(chunks):\n                embed.add_field(\n                    name=f\"Servers {i*10 + 1}-{min((i+1)*10, len(server_list))}\",\n                    value=\"\\n\\n\".join(chunk),\n                    inline=False\n                )\n        \n        embed.set_footer(text=translations.get_text(guild_id, 'servers_footer', len(self.bot.guilds)))\n        if self.bot.user.avatar:\n            embed.set_thumbnail(url=self.bot.user.avatar.url)\n        \n        await interaction.response.send_message(embed=embed, ephemeral=True)\n    \n    @app_commands.command(name=\"createinvite\", description=\"Create an invite for a server (Owner Only) / MeghÃ­vÃ³ lÃ©trehozÃ¡sa szerverhez\")\n    @app_commands.describe(server_id=\"Server ID to create invite for / Szerver ID meghÃ­vÃ³ lÃ©trehozÃ¡sÃ¡hoz\")\n    async def slash_createinvite(self, interaction: discord.Interaction, server_id: str):\n        if not await self.bot.is_owner(interaction.user):\n            await interaction.response.send_message(translations.get_text(interaction.guild.id, 'owner_only'), ephemeral=True)\n            return\n        \n        guild_id = interaction.guild.id if interaction.guild else None\n        \n        try:\n            target_server_id = int(server_id)\n        except ValueError:\n            await interaction.response.send_message(translations.get_text(guild_id, 'server_not_found'), ephemeral=True)\n            return\n        \n        guild = self.bot.get_guild(target_server_id)\n        \n        if guild is None:\n            await interaction.response.send_message(translations.get_text(guild_id, 'server_not_found'), ephemeral=True)\n            return\n        \n        text_channels = [ch for ch in guild.text_channels if ch.permissions_for(guild.me).create_instant_invite]\n        \n        if not text_channels:\n            await interaction.response.send_message(translations.get_text(guild_id, 'no_permission_invite', guild.name), ephemeral=True)\n            return\n        \n        channel = text_channels[0]\n        \n        try:\n            invite = await channel.create_invite(max_age=0, max_uses=0, reason=f\"Created by bot owner {interaction.user}\")\n            \n            embed = discord.Embed(\n                title=translations.get_text(guild_id, 'invite_created'),\n                description=translations.get_text(guild_id, 'invite_created_desc', guild.name),\n                color=0x00ffff\n            )\n            embed.add_field(name=translations.get_text(guild_id, 'invite_link'), value=invite.url, inline=False)\n            embed.add_field(name=translations.get_text(guild_id, 'invite_expires'), value=translations.get_text(guild_id, 'invite_never'), inline=True)\n            if guild.icon:\n                embed.set_thumbnail(url=guild.icon.url)\n            \n            await interaction.response.send_message(embed=embed, ephemeral=True)\n        \n        except discord.Forbidden:\n            await interaction.response.send_message(translations.get_text(guild_id, 'no_permission_invite', guild.name), ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"âŒ Error creating invite: {e}\", ephemeral=True)\n\n    @app_commands.command(name=\"addcc\", description=\"Add a custom command (Owner Only) / EgyÃ©ni parancs hozzÃ¡adÃ¡sa\")\n    @app_commands.describe(\n        name=\"Command name (without prefix) / Parancs neve (prefix nÃ©lkÃ¼l)\",\n        response=\"Command response text / Parancs vÃ¡lasz szÃ¶vege\"\n    )\n    async def slash_addcc(self, interaction: discord.Interaction, name: str, response: str):\n        if not await self.bot.is_owner(interaction.user):\n            await interaction.response.send_message(translations.get_text(interaction.guild.id, 'owner_only'), ephemeral=True)\n            return\n        \n        guild_id = interaction.guild.id\n        name = name.lower().strip()\n        \n        # Validate command name\n        if len(name) == 0:\n            await interaction.response.send_message(\"âŒ Command name cannot be empty!\", ephemeral=True)\n            return\n        \n        if ' ' in name:\n            await interaction.response.send_message(\"âŒ Command name cannot contain spaces!\", ephemeral=True)\n            return\n        \n        # Get custom commands cog\n        cc_cog = self.bot.get_cog('CustomCommands')\n        if not cc_cog:\n            await interaction.response.send_message(\"âŒ Custom commands system not loaded!\", ephemeral=True)\n            return\n        \n        # Check if command already exists\n        if name in cc_cog.custom_commands:\n            await interaction.response.send_message(f\"âŒ Custom command `{name}` already exists! Use `/mcc` to modify it.\", ephemeral=True)\n            return\n        \n        # Add custom command\n        cc_cog.custom_commands[name] = response\n        cc_cog.save_custom_commands()\n        \n        embed = discord.Embed(\n            title=\"âœ… Custom Command Added\",\n            description=f\"**Command:** `{name}`\\n**Response:** {response}\",\n            color=0x00FF00\n        )\n        embed.add_field(\n            name=\"Usage\",\n            value=f\"Users can now use: `!{name}` (or your custom prefix)\",\n            inline=False\n        )\n        embed.set_footer(text=f\"Total custom commands: {len(cc_cog.custom_commands)}\")\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"rcc\", description=\"Remove a custom command (Owner Only) / EgyÃ©ni parancs eltÃ¡volÃ­tÃ¡sa\")\n    @app_commands.describe(name=\"Command name to remove / EltÃ¡volÃ­tandÃ³ parancs neve\")\n    async def slash_rcc(self, interaction: discord.Interaction, name: str):\n        if not await self.bot.is_owner(interaction.user):\n            await interaction.response.send_message(translations.get_text(interaction.guild.id, 'owner_only'), ephemeral=True)\n            return\n        \n        guild_id = interaction.guild.id\n        name = name.lower().strip()\n        \n        # Get custom commands cog\n        cc_cog = self.bot.get_cog('CustomCommands')\n        if not cc_cog:\n            await interaction.response.send_message(\"âŒ Custom commands system not loaded!\", ephemeral=True)\n            return\n        \n        # Check if command exists\n        if name not in cc_cog.custom_commands:\n            await interaction.response.send_message(f\"âŒ Custom command `{name}` does not exist!\", ephemeral=True)\n            return\n        \n        # Remove custom command\n        old_response = cc_cog.custom_commands[name]\n        del cc_cog.custom_commands[name]\n        cc_cog.save_custom_commands()\n        \n        embed = discord.Embed(\n            title=\"ğŸ—‘ï¸ Custom Command Removed\",\n            description=f\"**Command:** `{name}`\\n**Old Response:** {old_response}\",\n            color=0xFF0000\n        )\n        embed.set_footer(text=f\"Total custom commands: {len(cc_cog.custom_commands)}\")\n        \n        await interaction.response.send_message(embed=embed)\n    \n    @app_commands.command(name=\"mcc\", description=\"Modify a custom command (Owner Only) / EgyÃ©ni parancs mÃ³dosÃ­tÃ¡sa\")\n    @app_commands.describe(\n        name=\"Command name to modify / MÃ³dosÃ­tandÃ³ parancs neve\",\n        response=\"New response text / Ãšj vÃ¡lasz szÃ¶vege\"\n    )\n    async def slash_mcc(self, interaction: discord.Interaction, name: str, response: str):\n        if not await self.bot.is_owner(interaction.user):\n            await interaction.response.send_message(translations.get_text(interaction.guild.id, 'owner_only'), ephemeral=True)\n            return\n        \n        guild_id = interaction.guild.id\n        name = name.lower().strip()\n        \n        # Get custom commands cog\n        cc_cog = self.bot.get_cog('CustomCommands')\n        if not cc_cog:\n            await interaction.response.send_message(\"âŒ Custom commands system not loaded!\", ephemeral=True)\n            return\n        \n        # Check if command exists\n        if name not in cc_cog.custom_commands:\n            await interaction.response.send_message(f\"âŒ Custom command `{name}` does not exist! Use `/addcc` to create it.\", ephemeral=True)\n            return\n        \n        # Modify custom command\n        old_response = cc_cog.custom_commands[name]\n        cc_cog.custom_commands[name] = response\n        cc_cog.save_custom_commands()\n        \n        embed = discord.Embed(\n            title=\"âœï¸ Custom Command Modified\",\n            description=f\"**Command:** `{name}`\",\n            color=0xFFFF00\n        )\n        embed.add_field(name=\"Old Response\", value=old_response[:1024], inline=False)\n        embed.add_field(name=\"New Response\", value=response[:1024], inline=False)\n        embed.set_footer(text=f\"Total custom commands: {len(cc_cog.custom_commands)}\")\n        \n        await interaction.response.send_message(embed=embed)\n\n    @app_commands.command(name=\"setbotprefix\", description=\"Change the bot command prefix / Bot parancs prefix megvÃ¡ltoztatÃ¡sa\")\n    @app_commands.describe(prefix=\"New prefix for bot commands / Ãšj prefix a bot parancsokhoz\")\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_setbotprefix(self, interaction: discord.Interaction, prefix: str):\n        guild_id = interaction.guild.id\n        \n        # Validate prefix\n        if len(prefix) > 5:\n            await interaction.response.send_message(\"âŒ Prefix must be 5 characters or less! / A prefix maximum 5 karakter lehet!\", ephemeral=True)\n            return\n        \n        if prefix == \"/\":\n            await interaction.response.send_message(\"âŒ Cannot use `/` as prefix (reserved for slash commands) / Nem hasznÃ¡lhatÃ³ a `/` prefix (fenntartva slash parancsokhoz)\", ephemeral=True)\n            return\n        \n        # Set new prefix\n        config.set_guild_prefix(guild_id, prefix)\n        \n        embed = discord.Embed(\n            title=\"âœ… Bot Prefix Updated / Prefix FrissÃ­tve\",\n            description=f\"**New prefix:** `{prefix}`\\n**Example:** `{prefix}help`\\n\\n**Ãšj prefix:** `{prefix}`\\n**PÃ©lda:** `{prefix}help`\",\n            color=0x00FF00\n        )\n        embed.add_field(\n            name=\"Note / MegjegyzÃ©s\",\n            value=\"Slash commands (/) still work! / A slash parancsok (/) tovÃ¡bbra is mÅ±kÃ¶dnek!\",\n            inline=False\n        )\n        \n        await interaction.response.send_message(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(SlashCommands(bot))\n","size_bytes":64832},"cogs/polls.py":{"content":"import discord\nfrom discord.ext import commands\nfrom discord.ui import Button, View\nfrom datetime import datetime, timezone\n\nclass PollView(View):\n    def __init__(self, poll_id, options):\n        super().__init__(timeout=None)\n        self.poll_id = poll_id\n        self.votes = {i: set() for i in range(len(options))}\n        \n        for i, option in enumerate(options):\n            button = Button(\n                label=f\"{option} (0)\",\n                style=discord.ButtonStyle.primary,\n                custom_id=f\"poll_{poll_id}_{i}\"\n            )\n            button.callback = self.create_vote_callback(i, option)\n            self.add_item(button)\n        \n        results_button = Button(\n            label=\"ğŸ“Š Show Results\",\n            style=discord.ButtonStyle.secondary,\n            custom_id=f\"poll_{poll_id}_results\"\n        )\n        results_button.callback = self.show_results\n        self.add_item(results_button)\n    \n    def create_vote_callback(self, option_index, option_text):\n        async def vote_callback(interaction: discord.Interaction):\n            user_id = interaction.user.id\n            \n            for i in self.votes:\n                if user_id in self.votes[i]:\n                    self.votes[i].remove(user_id)\n            \n            self.votes[option_index].add(user_id)\n            \n            for i, item in enumerate(self.children[:-1]):\n                if isinstance(item, Button):\n                    vote_count = len(self.votes[i])\n                    original_label = item.label.rsplit(' (', 1)[0]\n                    item.label = f\"{original_label} ({vote_count})\"\n            \n            await interaction.response.edit_message(view=self)\n            await interaction.followup.send(\n                f\"âœ… You voted for: **{option_text}**\",\n                ephemeral=True\n            )\n        \n        return vote_callback\n    \n    async def show_results(self, interaction: discord.Interaction):\n        total_votes = sum(len(votes) for votes in self.votes.values())\n        \n        results = \"ğŸ“Š **Poll Results:**\\n\\n\"\n        for i, votes in self.votes.items():\n            option_label = self.children[i].label.rsplit(' (', 1)[0]\n            vote_count = len(votes)\n            percentage = (vote_count / total_votes * 100) if total_votes > 0 else 0\n            bar_length = int(percentage / 5)\n            bar = \"â–ˆ\" * bar_length + \"â–‘\" * (20 - bar_length)\n            results += f\"**{option_label}**\\n{bar} {percentage:.1f}% ({vote_count} votes)\\n\\n\"\n        \n        results += f\"\\n**Total Votes:** {total_votes}\"\n        \n        embed = discord.Embed(\n            title=\"Poll Results\",\n            description=results,\n            color=0x8B00FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        await interaction.response.send_message(embed=embed, ephemeral=True)\n\nclass Polls(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.poll_counter = 0\n    \n    @commands.command(name='poll')\n    @commands.has_permissions(manage_messages=True)\n    async def create_poll(self, ctx, *, args):\n        parts = args.split('\"')\n        \n        if len(parts) < 3:\n            await ctx.send('âŒ Usage: `!poll \"Question here?\" \"Option 1\" \"Option 2\" ...`')\n            return\n        \n        question = parts[1]\n        options = [p.strip() for p in parts[2:] if p.strip() and p.strip() != '\"']\n        \n        if len(options) < 2:\n            await ctx.send(\"âŒ You need at least 2 options for a poll!\")\n            return\n        \n        if len(options) > 10:\n            await ctx.send(\"âŒ Maximum 10 options allowed!\")\n            return\n        \n        self.poll_counter += 1\n        \n        embed = discord.Embed(\n            title=f\"ğŸ“Š {question}\",\n            description=\"Click the buttons below to vote!\",\n            color=0x8B00FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        for i, option in enumerate(options, 1):\n            embed.add_field(name=f\"Option {i}\", value=option, inline=False)\n        \n        embed.set_footer(text=f\"Poll created by {ctx.author}\")\n        \n        view = PollView(self.poll_counter, options)\n        await ctx.send(embed=embed, view=view)\n        await ctx.message.delete()\n    \n    @commands.command(name='quickpoll')\n    @commands.has_permissions(manage_messages=True)\n    async def quick_poll(self, ctx, *, question):\n        embed = discord.Embed(\n            title=\"ğŸ“Š Quick Poll\",\n            description=question,\n            color=0x8B00FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        embed.set_footer(text=f\"Poll created by {ctx.author}\")\n        \n        message = await ctx.send(embed=embed)\n        await message.add_reaction(\"ğŸ‘\")\n        await message.add_reaction(\"ğŸ‘\")\n        await message.add_reaction(\"ğŸ¤·\")\n        await ctx.message.delete()\n\nasync def setup(bot):\n    await bot.add_cog(Polls(bot))\n","size_bytes":4948},"cogs/language.py":{"content":"import discord\nfrom discord import app_commands\nfrom discord.ext import commands\nimport translations\n\nclass Language(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name='setlang')\n    @commands.has_permissions(administrator=True)\n    async def set_language(self, ctx, lang: str):\n        \"\"\"Set the server language (en/hu)\"\"\"\n        lang = lang.lower()\n        \n        if lang not in ['en', 'hu']:\n            await ctx.send(translations.get_text(ctx.guild.id, 'invalid_language'))\n            return\n        \n        if translations.set_guild_language(ctx.guild.id, lang):\n            lang_name = translations.get_text(ctx.guild.id, f'language_{lang}', lang=lang)\n            \n            embed = discord.Embed(\n                title=translations.get_text(ctx.guild.id, 'language_set', lang=lang),\n                description=translations.get_text(ctx.guild.id, 'language_set_desc', lang_name, lang=lang),\n                color=discord.Color.green()\n            )\n            \n            embed.add_field(\n                name=translations.get_text(ctx.guild.id, 'current_language', lang=lang),\n                value=f\"ğŸ‡¬ğŸ‡§ English\" if lang == 'en' else f\"ğŸ‡­ğŸ‡º Magyar\",\n                inline=False\n            )\n            \n            await ctx.send(embed=embed)\n        else:\n            await ctx.send(translations.get_text(ctx.guild.id, 'error_setting_language'))\n    \n    @app_commands.command(name=\"setlang\", description=\"Set server language / Szerver nyelv beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(\n        language=\"Language to use / HasznÃ¡landÃ³ nyelv (en/hu)\"\n    )\n    @app_commands.choices(language=[\n        app_commands.Choice(name=\"ğŸ‡¬ğŸ‡§ English\", value=\"en\"),\n        app_commands.Choice(name=\"ğŸ‡­ğŸ‡º Magyar\", value=\"hu\")\n    ])\n    @app_commands.checks.has_permissions(administrator=True)\n    async def slash_setlang(self, interaction: discord.Interaction, language: app_commands.Choice[str]):\n        lang = language.value\n        \n        if translations.set_guild_language(interaction.guild.id, lang):\n            lang_name = translations.get_text(interaction.guild.id, f'language_{lang}', lang=lang)\n            \n            embed = discord.Embed(\n                title=translations.get_text(interaction.guild.id, 'language_set', lang=lang),\n                description=translations.get_text(interaction.guild.id, 'language_set_desc', lang_name, lang=lang),\n                color=discord.Color.green()\n            )\n            \n            embed.add_field(\n                name=translations.get_text(interaction.guild.id, 'current_language', lang=lang),\n                value=f\"ğŸ‡¬ğŸ‡§ English\" if lang == 'en' else f\"ğŸ‡­ğŸ‡º Magyar\",\n                inline=False\n            )\n            \n            await interaction.response.send_message(embed=embed)\n        else:\n            await interaction.response.send_message(translations.get_text(interaction.guild.id, 'error_setting_language'), ephemeral=True)\n\nasync def setup(bot):\n    await bot.add_cog(Language(bot))\n","size_bytes":3061},"cogs/roles.py":{"content":"import discord\nfrom discord.ext import commands\nfrom datetime import datetime, timezone\n\nclass Roles(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.command(name='createrole')\n    @commands.has_permissions(manage_roles=True)\n    async def create_role(self, ctx, name: str, color: str = None):\n        try:\n            role_color = discord.Color.default()\n            if color:\n                color = color.replace('#', '')\n                role_color = discord.Color(int(color, 16))\n            \n            role = await ctx.guild.create_role(name=name, color=role_color)\n            \n            embed = discord.Embed(\n                title=\"âœ… Role Created\",\n                description=f\"Role **{role.mention}** has been created!\",\n                color=discord.Color.green(),\n                timestamp=datetime.now(timezone.utc)\n            )\n            await ctx.send(embed=embed)\n        except ValueError:\n            await ctx.send(\"âŒ Invalid color format! Use hex color (e.g., #FF5733)\")\n        except Exception as e:\n            await ctx.send(f\"âŒ Error creating role: {str(e)}\")\n    \n    @commands.command(name='deleterole')\n    @commands.has_permissions(manage_roles=True)\n    async def delete_role(self, ctx, role: discord.Role):\n        if role >= ctx.author.top_role and ctx.author.id != ctx.guild.owner_id:\n            await ctx.send(\"âŒ You cannot delete a role higher than or equal to your highest role!\")\n            return\n        \n        role_name = role.name\n        await role.delete()\n        \n        embed = discord.Embed(\n            title=\"âœ… Role Deleted\",\n            description=f\"Role **{role_name}** has been deleted!\",\n            color=discord.Color.green(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='addrole')\n    @commands.has_permissions(manage_roles=True)\n    async def add_role(self, ctx, member: discord.Member, role: discord.Role):\n        if role >= ctx.author.top_role and ctx.author.id != ctx.guild.owner_id:\n            await ctx.send(\"âŒ You cannot assign a role higher than or equal to your highest role!\")\n            return\n        \n        if role in member.roles:\n            await ctx.send(f\"âŒ {member.mention} already has the {role.mention} role!\")\n            return\n        \n        await member.add_roles(role)\n        \n        embed = discord.Embed(\n            title=\"âœ… Role Added\",\n            description=f\"Added {role.mention} to {member.mention}\",\n            color=discord.Color.green(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='removerole')\n    @commands.has_permissions(manage_roles=True)\n    async def remove_role(self, ctx, member: discord.Member, role: discord.Role):\n        if role not in member.roles:\n            await ctx.send(f\"âŒ {member.mention} doesn't have the {role.mention} role!\")\n            return\n        \n        await member.remove_roles(role)\n        \n        embed = discord.Embed(\n            title=\"âœ… Role Removed\",\n            description=f\"Removed {role.mention} from {member.mention}\",\n            color=discord.Color.green(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='roleinfo')\n    async def role_info(self, ctx, role: discord.Role):\n        embed = discord.Embed(\n            title=f\"ğŸ“‹ Role Info: {role.name}\",\n            color=role.color,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.add_field(name=\"ID\", value=role.id, inline=True)\n        embed.add_field(name=\"Color\", value=str(role.color), inline=True)\n        embed.add_field(name=\"Position\", value=role.position, inline=True)\n        embed.add_field(name=\"Members\", value=len(role.members), inline=True)\n        embed.add_field(name=\"Mentionable\", value=\"Yes\" if role.mentionable else \"No\", inline=True)\n        embed.add_field(name=\"Hoisted\", value=\"Yes\" if role.hoist else \"No\", inline=True)\n        embed.add_field(name=\"Created\", value=role.created_at.strftime('%Y-%m-%d'), inline=True)\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='roles')\n    async def list_roles(self, ctx):\n        roles = sorted(ctx.guild.roles[1:], key=lambda r: r.position, reverse=True)\n        \n        embed = discord.Embed(\n            title=f\"ğŸ“‹ Server Roles ({len(roles)})\",\n            color=discord.Color.blue(),\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        role_list = \"\\n\".join([f\"{role.mention} - {len(role.members)} members\" for role in roles[:25]])\n        embed.description = role_list\n        \n        if len(roles) > 25:\n            embed.set_footer(text=f\"Showing 25 of {len(roles)} roles\")\n        \n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(Roles(bot))\n","size_bytes":4963},"cogs/tickets.py":{"content":"import discord\nfrom discord.ext import commands\nfrom discord.ui import Button, View\nimport config\n\nclass TicketView(View):\n    def __init__(self):\n        super().__init__(timeout=None)\n    \n    @discord.ui.button(label='ğŸ“© Create Ticket', style=discord.ButtonStyle.green, custom_id='create_ticket')\n    async def create_ticket(self, interaction: discord.Interaction, button: Button):\n        guild = interaction.guild\n        user = interaction.user\n        \n        cfg = config.load_config()\n        ticket_num = cfg.get('ticket_counter', 0) + 1\n        config.update_config('ticket_counter', ticket_num)\n        \n        category = None\n        if cfg.get('ticket_category_id'):\n            category = guild.get_channel(cfg['ticket_category_id'])\n        \n        overwrites = {\n            guild.default_role: discord.PermissionOverwrite(read_messages=False),\n            user: discord.PermissionOverwrite(read_messages=True, send_messages=True),\n            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)\n        }\n        \n        channel = await guild.create_text_channel(\n            name=f'ticket-{ticket_num}',\n            category=category,\n            overwrites=overwrites\n        )\n        \n        embed = discord.Embed(\n            title=f\"ğŸ« Ticket #{ticket_num}\",\n            description=f\"Welcome {user.mention}!\\n\\nPlease describe your issue and our staff will assist you shortly.\",\n            color=0x00F3FF\n        )\n        embed.set_footer(text=\"Click the button below to close this ticket\")\n        \n        close_view = CloseTicketView()\n        await channel.send(embed=embed, view=close_view)\n        \n        await interaction.response.send_message(\n            f\"âœ… Ticket created! {channel.mention}\",\n            ephemeral=True\n        )\n\nclass CloseTicketView(View):\n    def __init__(self):\n        super().__init__(timeout=None)\n    \n    @discord.ui.button(label='ğŸ”’ Close Ticket', style=discord.ButtonStyle.red, custom_id='close_ticket')\n    async def close_ticket(self, interaction: discord.Interaction, button: Button):\n        embed = discord.Embed(\n            title=\"ğŸ”’ Ticket Closed\",\n            description=f\"Ticket closed by {interaction.user.mention}\",\n            color=0xFF006E\n        )\n        \n        await interaction.response.send_message(embed=embed)\n        await interaction.channel.delete(reason=f\"Ticket closed by {interaction.user}\")\n\nclass Tickets(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        \n    @commands.command(name='ticket')\n    @commands.has_permissions(administrator=True)\n    async def create_ticket_panel(self, ctx):\n        embed = discord.Embed(\n            title=\"ğŸ« Support Tickets\",\n            description=\"Need help? Click the button below to create a support ticket!\\n\\nOur staff team will assist you as soon as possible.\",\n            color=0x8B00FF\n        )\n        embed.set_footer(text=\"One ticket per person\")\n        \n        view = TicketView()\n        await ctx.send(embed=embed, view=view)\n        await ctx.message.delete()\n    \n    @commands.command(name='closeticket')\n    @commands.has_permissions(manage_channels=True)\n    async def close_ticket_cmd(self, ctx):\n        if 'ticket-' in ctx.channel.name:\n            embed = discord.Embed(\n                title=\"ğŸ”’ Ticket Closed\",\n                description=f\"Ticket closed by {ctx.author.mention}\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            await ctx.channel.delete(reason=f\"Ticket closed by {ctx.author}\")\n        else:\n            await ctx.send(\"âŒ This command can only be used in ticket channels!\")\n\nasync def setup(bot):\n    await bot.add_cog(Tickets(bot))\n    bot.add_view(TicketView())\n    bot.add_view(CloseTicketView())\n","size_bytes":3806},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"aiohttp>=3.13.1\",\n    \"discord-py>=2.6.4\",\n    \"flask>=3.1.2\",\n    \"flask-cors>=6.0.1\",\n    \"gunicorn>=23.0.0\",\n    \"pillow>=12.0.0\",\n    \"pynacl>=1.6.0\",\n    \"python-dotenv>=1.1.1\",\n    \"spotipy>=2.25.1\",\n    \"wavelink>=3.4.1\",\n    \"yt-dlp>=2025.10.22\",\n]\n","size_bytes":404},"config.py":{"content":"import json\nimport os\n\nCONFIG_FILE = 'bot_config.json'\n\nDEFAULT_CONFIG = {\n    'log_channel_id': None,\n    'ticket_category_id': None,\n    'ticket_counter': 0,\n    'muted_roles': {},\n    'min_account_age_days': 7,\n    'warnings': {},\n    'temp_bans': {},\n    'temp_mutes': {},\n    'giveaways': {},\n    'completed_giveaways': {},\n    'role_prefixes': {},\n    'webhook_url': None,\n    'guild_languages': {},\n    'guild_prefixes': {}\n}\n\ndef load_config():\n    if os.path.exists(CONFIG_FILE):\n        with open(CONFIG_FILE, 'r') as f:\n            return json.load(f)\n    return DEFAULT_CONFIG.copy()\n\ndef save_config(config):\n    with open(CONFIG_FILE, 'w') as f:\n        json.dump(config, f, indent=4)\n\ndef get_config():\n    return load_config()\n\ndef update_config(key, value):\n    config = load_config()\n    config[key] = value\n    save_config(config)\n    return config\n\ndef get_guild_prefix(guild_id):\n    \"\"\"Get the prefix for a specific guild\"\"\"\n    config = load_config()\n    guild_prefixes = config.get('guild_prefixes', {})\n    return guild_prefixes.get(str(guild_id), '!')\n\ndef set_guild_prefix(guild_id, prefix):\n    \"\"\"Set the prefix for a specific guild\"\"\"\n    config = load_config()\n    if 'guild_prefixes' not in config:\n        config['guild_prefixes'] = {}\n    config['guild_prefixes'][str(guild_id)] = prefix\n    save_config(config)\n    return prefix\n","size_bytes":1364},"bot_launcher.py":{"content":"import subprocess\nimport sys\nimport time\nimport threading\n\ndef run_bot():\n    \"\"\"Run the Discord bot\"\"\"\n    print(\"ğŸ¤– Starting Discord Bot...\")\n    subprocess.run([sys.executable, \"main.py\"])\n\ndef run_web():\n    \"\"\"Run the Flask web server\"\"\"\n    time.sleep(3)  # Wait for bot to initialize\n    print(\"ğŸŒ Starting Web Server...\")\n    subprocess.run([sys.executable, \"web_server.py\"])\n\nif __name__ == \"__main__\":\n    bot_thread = threading.Thread(target=run_bot, daemon=False)\n    web_thread = threading.Thread(target=run_web, daemon=False)\n    \n    bot_thread.start()\n    web_thread.start()\n    \n    bot_thread.join()\n    web_thread.join()\n","size_bytes":644},"cogs/aichat.py":{"content":"import discord\nfrom discord.ext import commands\nfrom discord import app_commands\nimport aiohttp\nimport config\nfrom translations import get_text, get_guild_language\nimport os\n\nclass AIChat(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.openai_api_key = os.getenv('OPENAI_API_KEY')\n    \n    @app_commands.command(name=\"aichat\", description=\"Configure AI chat for a channel / AI csevegÃ©s beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(\n        channel=\"Channel for AI chat / Csatorna az AI csevegÃ©shez\",\n        language=\"AI response language (en/hu) / AI vÃ¡lasz nyelve\",\n        enabled=\"Enable or disable / BekapcsolÃ¡s vagy kikapcsolÃ¡s\"\n    )\n    @app_commands.checks.has_permissions(administrator=True)\n    async def aichat_config(\n        self, \n        interaction: discord.Interaction,\n        channel: discord.TextChannel,\n        language: str,\n        enabled: bool\n    ):\n        await interaction.response.defer()\n        \n        if language not in ['en', 'hu']:\n            await interaction.followup.send(\"âŒ Language must be 'en' or 'hu'\", ephemeral=True)\n            return\n        \n        if not self.openai_api_key:\n            await interaction.followup.send(\"âŒ OpenAI API key not configured! Please contact the bot owner.\", ephemeral=True)\n            return\n        \n        cfg = config.load_config()\n        if 'ai_chat_channels' not in cfg:\n            cfg['ai_chat_channels'] = {}\n        \n        channel_id = str(channel.id)\n        \n        if enabled:\n            cfg['ai_chat_channels'][channel_id] = {\n                'guild_id': str(interaction.guild.id),\n                'language': language,\n                'enabled': True\n            }\n            config.save_config(cfg)\n            \n            embed = discord.Embed(\n                title=\"âœ… AI Chat Enabled\",\n                description=f\"AI chat enabled in {channel.mention}\\n\\nThe bot will respond to all messages in this channel with AI-powered responses.\",\n                color=discord.Color.green()\n            )\n            embed.add_field(name=\"Language\", value=language.upper(), inline=True)\n            embed.add_field(name=\"Status\", value=\"âœ… Enabled\", inline=True)\n            embed.add_field(name=\"Note\", value=\"Messages starting with ! or / will be ignored\", inline=False)\n            \n            await interaction.followup.send(embed=embed)\n        else:\n            if channel_id in cfg.get('ai_chat_channels', {}):\n                del cfg['ai_chat_channels'][channel_id]\n                config.save_config(cfg)\n            \n            embed = discord.Embed(\n                title=\"ğŸ”‡ AI Chat Disabled\",\n                description=f\"AI chat disabled in {channel.mention}\",\n                color=discord.Color.red()\n            )\n            \n            await interaction.followup.send(embed=embed)\n    \n    @commands.Cog.listener()\n    async def on_message(self, message):\n        if message.author.bot:\n            return\n        \n        if not message.content or not message.content.strip():\n            return\n        \n        if message.content.startswith('!') or message.content.startswith('/'):\n            return\n        \n        if not self.openai_api_key:\n            return\n        \n        is_bot_mentioned = self.bot.user.mentioned_in(message) and not message.mention_everyone\n        \n        if not is_bot_mentioned:\n            return\n        \n        guild_lang = get_guild_language(str(message.guild.id))\n        ai_language = guild_lang if guild_lang in ['en', 'hu'] else 'en'\n        \n        async with message.channel.typing():\n            try:\n                clean_content = message.content.replace(f'<@{self.bot.user.id}>', '').replace(f'<@!{self.bot.user.id}>', '').strip()\n                \n                response_text = await self.get_ai_response(\n                    clean_content,\n                    ai_language\n                )\n                \n                if len(response_text) > 2000:\n                    chunks = [response_text[i:i+2000] for i in range(0, len(response_text), 2000)]\n                    for chunk in chunks:\n                        await message.reply(chunk, mention_author=False)\n                else:\n                    await message.reply(response_text, mention_author=False)\n                    \n            except Exception as e:\n                print(f\"AI Chat Error: {type(e).__name__}: {str(e)}\")\n                error_msg = \"âŒ Sorry, I couldn't process that message.\"\n                error_str = str(e).lower()\n                \n                if \"429\" in str(e) or \"quota\" in error_str or \"insufficient_quota\" in error_str:\n                    error_msg = \"âŒ AI chat is temporarily unavailable (API quota exceeded). Please contact the bot owner to add OpenAI credits.\"\n                elif \"rate_limit\" in error_str or \"rate limit\" in error_str:\n                    error_msg = \"âŒ Rate limit reached. Please try again in a few moments.\"\n                elif \"invalid\" in error_str or \"401\" in str(e):\n                    error_msg = \"âŒ API key issue. Please contact an administrator.\"\n                elif \"timeout\" in error_str:\n                    error_msg = \"âŒ Request timed out. Please try again.\"\n                \n                await message.reply(error_msg, mention_author=False)\n    \n    async def get_ai_response(self, user_message: str, language: str) -> str:\n        \"\"\"Get AI response from OpenAI API\"\"\"\n        \n        system_prompt = {\n            'en': \"You are a helpful and friendly Discord bot assistant. Keep responses concise and helpful.\",\n            'hu': \"Egy segÃ­tÅ‘kÃ©sz Ã©s barÃ¡tsÃ¡gos Discord bot asszisztens vagy. TÃ¶mÃ¶r Ã©s hasznos vÃ¡laszokat adj.\"\n        }\n        \n        headers = {\n            \"Authorization\": f\"Bearer {self.openai_api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        \n        data = {\n            \"model\": \"gpt-3.5-turbo\",\n            \"messages\": [\n                {\"role\": \"system\", \"content\": system_prompt.get(language, system_prompt['en'])},\n                {\"role\": \"user\", \"content\": user_message}\n            ],\n            \"max_tokens\": 500,\n            \"temperature\": 0.7\n        }\n        \n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                \"https://api.openai.com/v1/chat/completions\",\n                headers=headers,\n                json=data,\n                timeout=aiohttp.ClientTimeout(total=30)\n            ) as response:\n                if response.status == 200:\n                    result = await response.json()\n                    return result['choices'][0]['message']['content']\n                else:\n                    error_text = await response.text()\n                    print(f\"OpenAI API Error {response.status}: {error_text}\")\n                    raise Exception(f\"OpenAI API error {response.status}: {error_text[:100]}\")\n\nasync def setup(bot):\n    await bot.add_cog(AIChat(bot))\n","size_bytes":6983},"static/js/script.js":{"content":"// Auto-refresh stats every 30 seconds (prevent multiple intervals)\nif (!window.statsRefreshInterval) {\n    window.statsRefreshInterval = setInterval(async () => {\n        try {\n            const response = await fetch('/api/stats');\n            const data = await response.json();\n            \n            // Update stats if they've changed\n            updateStat('guilds', data.guilds);\n            updateStat('users', data.users);\n            updateStat('channels', data.channels);\n            \n            // Update uptime\n            const uptimeStr = formatUptime(data.uptime_seconds);\n            const uptimeElements = document.querySelectorAll('.stat-card:nth-child(4) .stat-value');\n            uptimeElements.forEach(el => el.textContent = uptimeStr);\n            \n        } catch (error) {\n            console.error('Failed to fetch stats:', error);\n        }\n    }, 30000);\n}\n\nfunction updateStat(statName, value) {\n    const statMap = {\n        'guilds': 1,\n        'users': 2,\n        'channels': 3\n    };\n    \n    const index = statMap[statName];\n    const element = document.querySelector(`.stat-card:nth-child(${index}) .stat-value`);\n    \n    if (element && element.textContent !== value.toString()) {\n        // Animate the change\n        element.style.transform = 'scale(1.2)';\n        element.style.color = '#ff006e';\n        \n        setTimeout(() => {\n            element.textContent = value;\n            element.style.transform = 'scale(1)';\n            element.style.color = 'var(--neon-cyan)';\n        }, 200);\n    }\n}\n\nfunction formatUptime(seconds) {\n    const days = Math.floor(seconds / 86400);\n    const hours = Math.floor((seconds % 86400) / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n    \n    return `${days}d ${hours}h ${minutes}m ${secs}s`;\n}\n\n// Add scroll animations\ndocument.addEventListener('DOMContentLoaded', () => {\n    const observer = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                entry.target.style.opacity = '1';\n                entry.target.style.transform = 'translateY(0)';\n            }\n        });\n    });\n\n    document.querySelectorAll('.stat-card, .feature-card').forEach(card => {\n        card.style.opacity = '0';\n        card.style.transform = 'translateY(20px)';\n        card.style.transition = 'all 0.6s ease';\n        observer.observe(card);\n    });\n});\n\n// Cyber grid effect on mouse move\ndocument.addEventListener('mousemove', (e) => {\n    const x = e.clientX / window.innerWidth;\n    const y = e.clientY / window.innerHeight;\n    \n    const stars = document.querySelector('.stars');\n    const stars2 = document.querySelector('.stars2');\n    const stars3 = document.querySelector('.stars3');\n    \n    if (stars) stars.style.transform = `translate(${x * 10}px, ${y * 10}px)`;\n    if (stars2) stars2.style.transform = `translate(${x * 20}px, ${y * 20}px)`;\n    if (stars3) stars3.style.transform = `translate(${x * 30}px, ${y * 30}px)`;\n});\n\n// Language translations\nconst translations = {\n    en: {\n        nav_dashboard: \"Dashboard\",\n        nav_commands: \"Commands\",\n        nav_support: \"Support\",\n        nav_addbot: \"Add Bot\",\n        view_all_commands: \"View All Commands\",\n        subtitle: \"Next-Gen Discord Moderation System\",\n        status_online: \"SYSTEM ONLINE\",\n        active_servers: \"Active Servers\",\n        total_users: \"Total Users\",\n        active_channels: \"Active Channels\",\n        system_uptime: \"System Uptime\",\n        core_features: \"CORE FEATURES\",\n        verification_title: \"Verification System\",\n        verification_desc: \"Anti-alt protection with button verification\",\n        ai_title: \"AI Assistant\",\n        ai_desc: \"OpenAI-powered chat responses\",\n        mod_title: \"Advanced Moderation\",\n        mod_desc: \"Ban, kick, timeout, warnings & more\",\n        music_title: \"Music Player\",\n        music_desc: \"ğŸ¥ YouTube â€¢ ğŸŸ¢ Spotify â€¢ â˜ï¸ SoundCloud\",\n        games_title: \"Interactive Games\",\n        games_desc: \"RPS, Tic-Tac-Toe & mini-games\",\n        multilang_title: \"Multilingual\",\n        multilang_desc: \"Full English & Hungarian support\",\n        slash_title: \"48 Slash Commands\",\n        slash_desc: \"! and / dual prefix support\",\n        quick_links: \"QUICK LINKS\",\n        join_support: \"Join Support Server\",\n        add_bot_server: \"Add Bot to Server\",\n        meet_dev: \"MEET THE DEVELOPER\",\n        owner_title: \"Bot Owner & Creator\",\n        owner_desc: \"Shadow-MOD is developed and maintained with passion to bring the next generation of Discord moderation to your servers. Built with cutting-edge technology and futuristic design, this bot combines powerful features with an intuitive user experience.\",\n        vision: \"Vision\",\n        vision_desc: \"Creating a futuristic Discord experience with AI-powered moderation, multilingual support, and seamless automation for communities worldwide.\",\n        powered_by: \"Powered by Replit â€¢ Created with ğŸ’œ\",\n        version: \"Made by MoonlightVFX\",\n        help_title: \"COMMAND DATABASE\",\n        help_subtitle: \"Made by MoonlightVFX\",\n        cat_info: \"INFORMATION SYSTEMS\",\n        cat_security: \"SECURITY & VERIFICATION\",\n        cat_antialt: \"ANTI-ALT SYSTEM\",\n        cat_mod: \"MODERATION MATRIX\",\n        cat_tickets: \"TICKET NEXUS\",\n        cat_games: \"GAMING ARENA\",\n        cat_fun: \"FUN PROTOCOLS\",\n        cat_polls: \"POLL SYSTEM\",\n        cat_roles: \"ROLE ARCHITECT\",\n        cat_giveaway: \"GIVEAWAY ENGINE\",\n        cat_nameauto: \"NAME AUTOMATION\",\n        cat_ai: \"AI NEURAL LINK\",\n        cat_entertainment: \"ENTERTAINMENT SYSTEMS\",\n        cat_engagement: \"ENGAGEMENT PROTOCOLS\",\n        cat_language: \"SYSTEM CONFIGURATION\"\n    },\n    hu: {\n        nav_dashboard: \"IrÃ¡nyÃ­tÃ³pult\",\n        nav_commands: \"Parancsok\",\n        nav_support: \"TÃ¡mogatÃ¡s\",\n        nav_addbot: \"Bot HozzÃ¡adÃ¡sa\",\n        view_all_commands: \"Ã–sszes Parancs MegtekintÃ©se\",\n        subtitle: \"KÃ¶vetkezÅ‘ GenerÃ¡ciÃ³s Discord ModerÃ¡ciÃ³s Rendszer\",\n        status_online: \"RENDSZER ONLINE\",\n        active_servers: \"AktÃ­v Szerverek\",\n        total_users: \"Ã–sszes FelhasznÃ¡lÃ³\",\n        active_channels: \"AktÃ­v CsatornÃ¡k\",\n        system_uptime: \"Rendszer ÃœzemidÅ‘\",\n        core_features: \"ALAPVETÅ FUNKCIÃ“K\",\n        verification_title: \"EllenÅ‘rzÅ‘ Rendszer\",\n        verification_desc: \"Anti-alt vÃ©delem gombos ellenÅ‘rzÃ©ssel\",\n        ai_title: \"AI Asszisztens\",\n        ai_desc: \"OpenAI-alapÃº chat vÃ¡laszok\",\n        mod_title: \"Fejlett ModerÃ¡ciÃ³\",\n        mod_desc: \"KitiltÃ¡s, kirÃºgÃ¡s, timeout, figyelmeztetÃ©sek\",\n        music_title: \"Zene LejÃ¡tszÃ³\",\n        music_desc: \"ğŸ¥ YouTube â€¢ ğŸŸ¢ Spotify â€¢ â˜ï¸ SoundCloud\",\n        games_title: \"InteraktÃ­v JÃ¡tÃ©kok\",\n        games_desc: \"KÅ‘-PapÃ­r-OllÃ³, Tic-Tac-Toe Ã©s mini jÃ¡tÃ©kok\",\n        multilang_title: \"TÃ¶bbnyelvÅ±\",\n        multilang_desc: \"Teljes angol Ã©s magyar tÃ¡mogatÃ¡s\",\n        slash_title: \"48 Slash Parancs\",\n        slash_desc: \"! Ã©s / dupla prefix tÃ¡mogatÃ¡s\",\n        quick_links: \"GYORS LINKEK\",\n        join_support: \"Csatlakozz a TÃ¡mogatÃ³i Szerverhez\",\n        add_bot_server: \"Bot HozzÃ¡adÃ¡sa Szerverhez\",\n        meet_dev: \"ISMERD MEG A FEJLESZTÅT\",\n        owner_title: \"Bot Tulajdonos Ã©s KÃ©szÃ­tÅ‘\",\n        owner_desc: \"A Shadow-MOD szenvedÃ©llyel van fejlesztve Ã©s karbantartva, hogy a Discord moderÃ¡ciÃ³ kÃ¶vetkezÅ‘ generÃ¡ciÃ³jÃ¡t hozza el szervereidre. Ã‰lvonalbeli technolÃ³giÃ¡val Ã©s futurisztikus dizÃ¡jnnal Ã©pÃ¼lt, ez a bot erÅ‘teljes funkciÃ³kat kombinÃ¡l intuitÃ­v felhasznÃ¡lÃ³i Ã©lmÃ©nnyel.\",\n        vision: \"JÃ¶vÅ‘kÃ©p\",\n        vision_desc: \"Futurisztikus Discord Ã©lmÃ©ny megteremtÃ©se AI-alapÃº moderÃ¡ciÃ³val, tÃ¶bbnyelvÅ± tÃ¡mogatÃ¡ssal Ã©s zÃ¶kkenÅ‘mentes automatizÃ¡lÃ¡ssal kÃ¶zÃ¶ssÃ©gek szÃ¡mÃ¡ra vilÃ¡gszerte.\",\n        powered_by: \"Powered by Replit â€¢ KÃ©szÃ­tve ğŸ’œ-tel\",\n        version: \"MoonlightVFX Ã¡ltal kÃ©szÃ­tve\",\n        help_title: \"PARANCSADATBÃZIS\",\n        help_subtitle: \"MoonlightVFX Ã¡ltal kÃ©szÃ­tve\",\n        cat_info: \"INFORMÃCIÃ“S RENDSZEREK\",\n        cat_security: \"BIZTONSÃG Ã‰S ELLENÅRZÃ‰S\",\n        cat_antialt: \"ANTI-ALT RENDSZER\",\n        cat_mod: \"MODERÃCIÃ“S MÃTRIX\",\n        cat_tickets: \"TICKET NEXUS\",\n        cat_games: \"JÃTÃ‰K ARÃ‰NA\",\n        cat_fun: \"SZÃ“RAKOZÃS PROTOKOLLOK\",\n        cat_polls: \"SZAVAZÃS RENDSZER\",\n        cat_roles: \"SZEREPKÃ–R Ã‰PÃTÃ‰SZ\",\n        cat_giveaway: \"NYEREMÃ‰NYJÃTÃ‰K MOTOR\",\n        cat_nameauto: \"NÃ‰V AUTOMATIZÃLÃS\",\n        cat_ai: \"AI NEURÃLIS LINK\",\n        cat_entertainment: \"SZÃ“RAKOZTATÃSI RENDSZEREK\",\n        cat_engagement: \"KÃ–ZÃ–SSÃ‰GI PROTOKOLLOK\",\n        cat_language: \"RENDSZER KONFIGURÃCIÃ“\"\n    }\n};\n\n// Language switching functionality\nlet currentLang = localStorage.getItem('language') || 'en';\n\nfunction setLanguage(lang) {\n    currentLang = lang;\n    localStorage.setItem('language', lang);\n    \n    // Update all translatable elements\n    document.querySelectorAll('[data-translate]').forEach(element => {\n        const key = element.getAttribute('data-translate');\n        if (translations[lang] && translations[lang][key]) {\n            element.textContent = translations[lang][key];\n        }\n    });\n    \n    // Update toggle state\n    const toggle = document.getElementById('langToggle');\n    if (toggle) {\n        toggle.checked = (lang === 'hu');\n    }\n}\n\n// Initialize language on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n    setLanguage(currentLang);\n    \n    // Setup language toggle listener\n    const toggle = document.getElementById('langToggle');\n    if (toggle) {\n        toggle.addEventListener('change', (e) => {\n            setLanguage(e.target.checked ? 'hu' : 'en');\n        });\n    }\n});\n\n// CSS for toggle slider animation\nconst style = document.createElement('style');\nstyle.textContent = `\n    #langToggle:checked + span + span {\n        transform: translateX(26px);\n    }\n`;\ndocument.head.appendChild(style);\n","size_bytes":10038},"cogs/verify.py":{"content":"import discord\nfrom discord.ext import commands\nfrom discord import app_commands\nimport config\nfrom translations import get_text\nfrom datetime import datetime, timezone, timedelta\n\nclass VerifyButton(discord.ui.View):\n    def __init__(self):\n        super().__init__(timeout=None)\n    \n    @discord.ui.button(label=\"Verify\", style=discord.ButtonStyle.green, emoji=\"âœ…\", custom_id=\"verify_button\")\n    async def verify_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        cfg = config.load_config()\n        guild_id = str(interaction.guild.id)\n        \n        verify_config = cfg.get('verify_config', {}).get(guild_id)\n        if not verify_config:\n            await interaction.response.send_message(\"âŒ Verification not configured!\", ephemeral=True)\n            return\n        \n        min_account_age = cfg.get('min_account_age_days', {}).get(guild_id, 7)\n        \n        account_age = (datetime.now(timezone.utc) - interaction.user.created_at).days\n        \n        if account_age < min_account_age:\n            await interaction.response.send_message(\n                f\"âŒ Your account is too new! Minimum age: {min_account_age} days. Your account: {account_age} days.\",\n                ephemeral=True\n            )\n            return\n        \n        roles_to_add = verify_config.get('roles_to_add', [])\n        roles_to_remove = verify_config.get('roles_to_remove', [])\n        \n        added_roles = []\n        removed_roles = []\n        \n        for role_id in roles_to_add:\n            role = interaction.guild.get_role(int(role_id))\n            if role and role not in interaction.user.roles:\n                try:\n                    await interaction.user.add_roles(role)\n                    added_roles.append(role.name)\n                except:\n                    pass\n        \n        for role_id in roles_to_remove:\n            role = interaction.guild.get_role(int(role_id))\n            if role and role in interaction.user.roles:\n                try:\n                    await interaction.user.remove_roles(role)\n                    removed_roles.append(role.name)\n                except:\n                    pass\n        \n        embed = discord.Embed(\n            title=\"âœ… Verified Successfully!\",\n            description=f\"Welcome {interaction.user.mention}! You have been verified.\",\n            color=0x00F3FF\n        )\n        \n        if added_roles:\n            embed.add_field(name=\"Roles Added\", value=\", \".join(added_roles), inline=False)\n        if removed_roles:\n            embed.add_field(name=\"Roles Removed\", value=\", \".join(removed_roles), inline=False)\n        \n        await interaction.response.send_message(embed=embed, ephemeral=True)\n        \n        log_embed = discord.Embed(\n            title=\"âœ… Member Verified\",\n            description=f\"{interaction.user.mention} has been verified\",\n            color=0x00F3FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        log_embed.add_field(name=\"User\", value=f\"{interaction.user} ({interaction.user.id})\", inline=False)\n        log_embed.add_field(name=\"Account Age\", value=f\"{account_age} days\", inline=True)\n        \n        log_channel_id = cfg.get('log_channel_id')\n        if log_channel_id:\n            log_channel = interaction.guild.get_channel(log_channel_id)\n            if log_channel:\n                await log_channel.send(embed=log_embed)\n\nclass Verify(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.bot.add_view(VerifyButton())\n    \n    @app_commands.command(name=\"setupverify\", description=\"Setup verification system / EllenÅ‘rzÃ©si rendszer beÃ¡llÃ­tÃ¡sa\")\n    @app_commands.describe(\n        channel=\"Channel for verification panel / Csatorna az ellenÅ‘rzÅ‘ panelhez\",\n        roles_to_add=\"Roles to add (comma separated) / HozzÃ¡adandÃ³ szerepek (vesszÅ‘vel elvÃ¡lasztva)\",\n        roles_to_remove=\"Roles to remove (comma separated) / EltÃ¡volÃ­tandÃ³ szerepek (vesszÅ‘vel elvÃ¡lasztva)\"\n    )\n    @app_commands.checks.has_permissions(administrator=True)\n    async def setup_verify(\n        self, \n        interaction: discord.Interaction,\n        channel: discord.TextChannel,\n        roles_to_add: str = \"\",\n        roles_to_remove: str = \"\"\n    ):\n        await interaction.response.defer()\n        \n        cfg = config.load_config()\n        guild_id = str(interaction.guild.id)\n        \n        if 'verify_config' not in cfg:\n            cfg['verify_config'] = {}\n        \n        add_role_ids = []\n        remove_role_ids = []\n        \n        if roles_to_add.strip():\n            for role_mention in roles_to_add.split(','):\n                role_mention = role_mention.strip()\n                if role_mention.startswith('<@&') and role_mention.endswith('>'):\n                    role_id = role_mention[3:-1]\n                    role = interaction.guild.get_role(int(role_id))\n                    if role:\n                        add_role_ids.append(str(role.id))\n        \n        if roles_to_remove.strip():\n            for role_mention in roles_to_remove.split(','):\n                role_mention = role_mention.strip()\n                if role_mention.startswith('<@&') and role_mention.endswith('>'):\n                    role_id = role_mention[3:-1]\n                    role = interaction.guild.get_role(int(role_id))\n                    if role:\n                        remove_role_ids.append(str(role.id))\n        \n        cfg['verify_config'][guild_id] = {\n            'channel_id': str(channel.id),\n            'roles_to_add': add_role_ids,\n            'roles_to_remove': remove_role_ids\n        }\n        config.save_config(cfg)\n        \n        min_age = cfg.get('min_account_age_days', {}).get(guild_id, 7)\n        \n        verify_embed = discord.Embed(\n            title=\"âœ… Verification\",\n            description=f\"Click the button below to verify yourself!\\n\\n**Requirements:**\\nâ€¢ Account must be at least {min_age} days old\",\n            color=0x8B00FF\n        )\n        verify_embed.add_field(\n            name=\"What happens when you verify?\",\n            value=\"You will gain access to the server and receive your member roles.\",\n            inline=False\n        )\n        \n        view = VerifyButton()\n        await channel.send(embed=verify_embed, view=view)\n        \n        config_embed = discord.Embed(\n            title=\"âœ… Verification System Configured\",\n            description=f\"Verification panel sent to {channel.mention}\",\n            color=0x00F3FF\n        )\n        config_embed.add_field(name=\"Minimum Account Age\", value=f\"{min_age} days\", inline=False)\n        \n        if add_role_ids:\n            role_names = [interaction.guild.get_role(int(rid)).name for rid in add_role_ids if interaction.guild.get_role(int(rid))]\n            config_embed.add_field(name=\"Roles to Add\", value=\", \".join(role_names) if role_names else \"None\", inline=False)\n        \n        if remove_role_ids:\n            role_names = [interaction.guild.get_role(int(rid)).name for rid in remove_role_ids if interaction.guild.get_role(int(rid))]\n            config_embed.add_field(name=\"Roles to Remove\", value=\", \".join(role_names) if role_names else \"None\", inline=False)\n        \n        await interaction.followup.send(embed=config_embed)\n    \n    @commands.command(name='setupverify')\n    @commands.has_permissions(administrator=True)\n    async def setup_verify_prefix(self, ctx, channel: discord.TextChannel, *, roles: str = \"\"):\n        await ctx.send(\"âš ï¸ Please use the slash command `/setupverify` for easier configuration!\")\n\nasync def setup(bot):\n    await bot.add_cog(Verify(bot))\n","size_bytes":7610},"static/css/style.css":{"content":"@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap');\n\n:root {\n    --neon-cyan: #00f3ff;\n    --neon-pink: #ff006e;\n    --neon-purple: #8b00ff;\n    --neon-blue: #0066ff;\n    --dark-bg: #0a0a0f;\n    --card-bg: #151520;\n    --text-primary: #ffffff;\n    --text-secondary: #a0a0b0;\n}\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\nbody {\n    font-family: 'Rajdhani', sans-serif;\n    background: var(--dark-bg);\n    color: var(--text-primary);\n    overflow-x: hidden;\n    min-height: 100vh;\n}\n\n/* Force remove any cyan borders/outlines globally */\n.header *:not(.cyber-glitch):not(.sparkle):not(.pulse) {\n    border: none !important;\n    outline: none !important;\n}\n\n.header br {\n    display: block;\n    margin: 10px 0;\n}\n\n/* Animated Starfield Background - Reduced intensity */\n.stars, .stars2, .stars3 {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    z-index: 0;\n}\n\n.stars {\n    background: transparent url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"2\" height=\"2\"><circle cx=\"1\" cy=\"1\" r=\"1\" fill=\"white\" opacity=\"0.3\"/></svg>') repeat;\n    animation: starsMove 120s linear infinite;\n}\n\n.stars2 {\n    background: transparent url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"3\" height=\"3\"><circle cx=\"1.5\" cy=\"1.5\" r=\"1\" fill=\"%2300f3ff\" opacity=\"0.2\"/></svg>') repeat;\n    animation: starsMove 180s linear infinite;\n}\n\n.stars3 {\n    background: transparent url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"4\" height=\"4\"><circle cx=\"2\" cy=\"2\" r=\"1.5\" fill=\"%238b00ff\" opacity=\"0.15\"/></svg>') repeat;\n    animation: starsMove 240s linear infinite;\n}\n\n@keyframes starsMove {\n    from { transform: translateY(0); }\n    to { transform: translateY(-2000px); }\n}\n\n/* Container */\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    padding: 40px 20px;\n    position: relative;\n    z-index: 1;\n}\n\n/* Header */\n.header {\n    text-align: center;\n    margin-bottom: 60px;\n    position: relative;\n    z-index: 10;\n    border: none !important;\n    outline: none !important;\n}\n\n.header::before,\n.header::after {\n    content: none !important;\n    display: none !important;\n    border: none !important;\n    background: none !important;\n}\n\n.header *::before,\n.header *::after {\n    content: none !important;\n    display: none !important;\n    border: none !important;\n    background: transparent !important;\n}\n\n.command-button {\n    display: inline-block;\n    padding: 10px 25px;\n    background: linear-gradient(135deg, #8B00FF, #FF006E);\n    color: white;\n    text-decoration: none;\n    border-radius: 20px;\n    font-weight: bold;\n    transition: all 0.3s ease;\n    box-shadow: 0 5px 15px rgba(139, 0, 255, 0.4);\n    border: none !important;\n    outline: none !important;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-user-select: none;\n    user-select: none;\n}\n\n.command-button:focus,\n.command-button:active,\n.command-button:visited,\n.command-button:hover {\n    outline: none !important;\n    border: none !important;\n    box-shadow: 0 5px 15px rgba(139, 0, 255, 0.4);\n    -webkit-tap-highlight-color: transparent;\n}\n\n.logo-container {\n    position: relative;\n    display: inline-block;\n}\n\n.logo-glow {\n    display: none !important;\n}\n\n.title {\n    font-family: 'Orbitron', sans-serif;\n    font-size: 4rem;\n    font-weight: 900;\n    margin-bottom: 10px;\n    position: relative;\n}\n\n.cyber-glitch {\n    position: relative;\n    color: var(--neon-cyan);\n    text-shadow: \n        0 0 5px var(--neon-cyan),\n        0 0 10px var(--neon-cyan),\n        2px 2px 4px rgba(0, 0, 0, 0.8),\n        -1px -1px 2px rgba(0, 0, 0, 0.8);\n    animation: glitch 5s infinite;\n    -webkit-text-stroke: 1px rgba(0, 0, 0, 0.5);\n}\n\n@keyframes glitch {\n    0%, 100% { transform: translate(0); }\n    20% { transform: translate(-2px, 2px); }\n    40% { transform: translate(2px, -2px); }\n    60% { transform: translate(-2px, -2px); }\n    80% { transform: translate(2px, 2px); }\n}\n\n.sparkle {\n    display: inline-block;\n    animation: sparkle 2s ease-in-out infinite;\n}\n\n@keyframes sparkle {\n    0%, 100% { transform: scale(1) rotate(0deg); opacity: 1; }\n    50% { transform: scale(1.3) rotate(180deg); opacity: 0.7; }\n}\n\n.subtitle {\n    font-size: 1.3rem;\n    color: var(--text-secondary);\n    letter-spacing: 4px;\n    text-transform: uppercase;\n    margin-bottom: 20px;\n    text-shadow: \n        1px 1px 3px rgba(0, 0, 0, 0.9),\n        -1px -1px 2px rgba(0, 0, 0, 0.9);\n}\n\n.status-badge {\n    display: inline-block;\n    padding: 10px 30px;\n    border-radius: 30px;\n    font-weight: 600;\n    border: none;\n    position: relative;\n    overflow: hidden;\n    box-shadow: none;\n}\n\n.status-badge.online {\n    background: linear-gradient(90deg, rgba(0,243,255,0.2), rgba(0,243,255,0.1));\n    color: var(--neon-cyan);\n}\n\n.pulse {\n    position: absolute;\n    left: 10px;\n    top: 50%;\n    transform: translateY(-50%);\n    width: 8px;\n    height: 8px;\n    background: var(--neon-cyan);\n    border-radius: 50%;\n    animation: pulse 2s ease-in-out infinite;\n}\n\n@keyframes pulse {\n    0%, 100% { opacity: 1; box-shadow: 0 0 10px var(--neon-cyan); }\n    50% { opacity: 0.5; box-shadow: 0 0 20px var(--neon-cyan); }\n}\n\n/* Stats Grid */\n.stats-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n    gap: 30px;\n    margin-bottom: 80px;\n    position: relative;\n    z-index: 1;\n}\n\n.stat-card {\n    background: var(--card-bg);\n    border: 2px solid rgba(0,243,255,0.2);\n    border-radius: 20px;\n    padding: 40px 30px;\n    text-align: center;\n    position: relative;\n    overflow: hidden;\n    transition: all 0.3s ease;\n}\n\n.stat-card:hover {\n    border-color: var(--neon-cyan);\n    transform: translateY(-10px);\n    box-shadow: 0 20px 40px rgba(0,243,255,0.3);\n}\n\n.stat-glow {\n    position: absolute;\n    top: -50%;\n    left: -50%;\n    width: 200%;\n    height: 200%;\n    background: radial-gradient(circle, rgba(0,243,255,0.1) 0%, transparent 70%);\n    opacity: 0;\n    transition: opacity 0.3s;\n}\n\n.stat-card:hover .stat-glow {\n    opacity: 1;\n}\n\n.stat-icon {\n    font-size: 3rem;\n    margin-bottom: 15px;\n    filter: drop-shadow(0 0 10px var(--neon-cyan));\n}\n\n.stat-value {\n    font-family: 'Orbitron', sans-serif;\n    font-size: 2.5rem;\n    font-weight: 700;\n    color: var(--neon-cyan);\n    margin-bottom: 10px;\n    text-shadow: \n        0 0 5px var(--neon-cyan),\n        2px 2px 4px rgba(0, 0, 0, 0.8);\n    -webkit-text-stroke: 0.5px rgba(0, 0, 0, 0.5);\n}\n\n.stat-label {\n    font-size: 1.1rem;\n    color: var(--text-secondary);\n    text-transform: uppercase;\n    letter-spacing: 2px;\n    text-shadow: \n        1px 1px 2px rgba(0, 0, 0, 0.9),\n        -1px -1px 2px rgba(0, 0, 0, 0.9);\n}\n\n/* Features Section */\n.features-section {\n    margin-bottom: 80px;\n}\n\n.section-title {\n    font-family: 'Orbitron', sans-serif;\n    font-size: 2rem;\n    text-align: center;\n    margin-bottom: 50px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 20px;\n    color: var(--neon-pink);\n    text-shadow: \n        0 0 5px var(--neon-pink),\n        2px 2px 4px rgba(0, 0, 0, 0.8);\n    -webkit-text-stroke: 0.5px rgba(0, 0, 0, 0.5);\n}\n\n.cyber-line {\n    width: 100px;\n    height: 2px;\n    background: linear-gradient(90deg, transparent, var(--neon-pink), transparent);\n}\n\n.features-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 25px;\n}\n\n.feature-card {\n    background: linear-gradient(135deg, rgba(139,0,255,0.1), rgba(255,0,110,0.1));\n    border: 2px solid rgba(139,0,255,0.3);\n    border-radius: 15px;\n    padding: 30px;\n    transition: all 0.3s ease;\n}\n\n.feature-card:hover {\n    border-color: var(--neon-purple);\n    transform: scale(1.05);\n    box-shadow: 0 10px 30px rgba(139,0,255,0.4);\n}\n\n.feature-icon {\n    font-size: 3rem;\n    margin-bottom: 15px;\n}\n\n.feature-card h3 {\n    font-family: 'Orbitron', sans-serif;\n    font-size: 1.3rem;\n    margin-bottom: 10px;\n    color: var(--neon-purple);\n    text-shadow: \n        1px 1px 3px rgba(0, 0, 0, 0.9),\n        -1px -1px 2px rgba(0, 0, 0, 0.9);\n}\n\n.feature-card p {\n    color: var(--text-secondary);\n    line-height: 1.6;\n    text-shadow: \n        1px 1px 2px rgba(0, 0, 0, 0.9),\n        -1px -1px 2px rgba(0, 0, 0, 0.9);\n}\n\n/* Tech Stack */\n.tech-stack {\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n    gap: 20px;\n    margin-bottom: 60px;\n}\n\n.tech-item {\n    background: rgba(0,102,255,0.1);\n    border: 1px solid var(--neon-blue);\n    border-radius: 25px;\n    padding: 10px 25px;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    font-weight: 600;\n    color: var(--neon-blue);\n}\n\n.tech-dot {\n    width: 8px;\n    height: 8px;\n    background: var(--neon-blue);\n    border-radius: 50%;\n    box-shadow: 0 0 10px var(--neon-blue);\n    animation: pulse 2s infinite;\n}\n\n/* Footer */\n.footer {\n    text-align: center;\n    padding: 40px 0;\n    border-top: 1px solid rgba(255,255,255,0.1);\n    color: var(--text-secondary);\n}\n\n.version {\n    margin-top: 10px;\n    font-family: 'Orbitron', sans-serif;\n    color: var(--neon-cyan);\n    font-weight: 600;\n}\n\n/* Navigation Bar */\n.navbar {\n    background: rgba(0, 0, 0, 0.8);\n    backdrop-filter: blur(10px);\n    border-bottom: 2px solid rgba(0, 243, 255, 0.3);\n    padding: 15px 0;\n    position: sticky;\n    top: 0;\n    z-index: 1000;\n}\n\n.nav-container {\n    max-width: 1200px;\n    margin: 0 auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    gap: 25px;\n    flex-wrap: wrap;\n    padding: 0 20px;\n}\n\n.nav-link {\n    display: inline-block;\n    color: #00F3FF;\n    text-decoration: none;\n    font-weight: bold;\n    font-size: 1.1em;\n    padding: 12px 28px;\n    border-radius: 15px;\n    transition: all 0.3s ease;\n    background: rgba(0, 243, 255, 0.1);\n    border: 2px solid rgba(0, 243, 255, 0.3);\n    white-space: nowrap;\n    cursor: pointer;\n    min-height: 44px;\n    line-height: 1.5;\n}\n\n.nav-link:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 5px 15px rgba(0, 243, 255, 0.4);\n    border-color: rgba(0, 243, 255, 0.6);\n    background: rgba(0, 243, 255, 0.15);\n}\n\n.nav-link.pink {\n    color: #FF006E;\n    background: rgba(255, 0, 110, 0.1);\n    border: 2px solid rgba(255, 0, 110, 0.3);\n}\n\n.nav-link.pink:hover {\n    border-color: rgba(255, 0, 110, 0.6);\n    background: rgba(255, 0, 110, 0.15);\n    box-shadow: 0 5px 15px rgba(255, 0, 110, 0.4);\n}\n\n.nav-link.purple {\n    color: #8B00FF;\n    background: rgba(139, 0, 255, 0.1);\n    border: 2px solid rgba(139, 0, 255, 0.3);\n}\n\n.nav-link.purple:hover {\n    border-color: rgba(139, 0, 255, 0.6);\n    background: rgba(139, 0, 255, 0.15);\n    box-shadow: 0 5px 15px rgba(139, 0, 255, 0.4);\n}\n\n.nav-link.gradient {\n    color: #00F3FF;\n    background: linear-gradient(135deg, #FF006E, #8B00FF);\n    border: 2px solid rgba(255, 0, 110, 0.5);\n}\n\n.nav-link.gradient:hover {\n    border-color: rgba(255, 0, 110, 0.8);\n    box-shadow: 0 5px 15px rgba(255, 0, 110, 0.6);\n}\n\n.lang-toggle-container {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 5px 15px;\n    background: rgba(139, 0, 255, 0.1);\n    border: 1px solid rgba(139, 0, 255, 0.3);\n    border-radius: 20px;\n}\n\n.lang-label {\n    font-weight: bold;\n    font-size: 0.9em;\n}\n\n.lang-label.en {\n    color: #00F3FF;\n}\n\n.lang-label.hu {\n    color: #FF006E;\n}\n\n.toggle-switch {\n    position: relative;\n    display: inline-block;\n    width: 50px;\n    height: 24px;\n    cursor: pointer;\n}\n\n.toggle-switch input {\n    opacity: 0;\n    width: 0;\n    height: 0;\n}\n\n.toggle-slider {\n    position: absolute;\n    cursor: pointer;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(135deg, #00F3FF, #8B00FF);\n    border-radius: 24px;\n    transition: 0.4s;\n    box-shadow: 0 0 10px rgba(0, 243, 255, 0.5);\n}\n\n.toggle-knob {\n    position: absolute;\n    content: '';\n    height: 18px;\n    width: 18px;\n    left: 3px;\n    bottom: 3px;\n    background-color: white;\n    border-radius: 50%;\n    transition: 0.4s;\n    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);\n}\n\n/* Responsive */\n@media (max-width: 768px) {\n    .title {\n        font-size: 2.5rem;\n    }\n    \n    .header {\n        margin-bottom: 100px;\n    }\n    \n    .stats-grid {\n        grid-template-columns: 1fr;\n        margin-top: 60px;\n    }\n    \n    .stat-card {\n        border-color: rgba(139,0,255,0.3);\n    }\n    \n    .features-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    /* Mobile Navigation */\n    .navbar {\n        padding: 12px 0;\n    }\n    \n    .nav-container {\n        gap: 12px;\n        padding: 0 10px;\n    }\n    \n    .nav-link {\n        font-size: 1em;\n        padding: 14px 20px;\n        min-height: 48px;\n    }\n    \n    .lang-toggle-container {\n        padding: 3px 10px;\n        gap: 6px;\n    }\n    \n    .toggle-switch {\n        width: 40px;\n        height: 20px;\n    }\n    \n    .toggle-knob {\n        height: 14px;\n        width: 14px;\n    }\n    \n    .lang-label {\n        font-size: 0.75em;\n    }\n}\n\n@media (max-width: 480px) {\n    /* Extra small mobile screens */\n    .nav-link {\n        font-size: 1.2em;\n        padding: 12px 16px;\n        min-height: 44px;\n    }\n    \n    .nav-link span {\n        display: none;\n    }\n    \n    .nav-container {\n        gap: 10px;\n    }\n}\n","size_bytes":13457},"web_server.py":{"content":"from flask import Flask, render_template, jsonify, redirect\nfrom flask_cors import CORS\nfrom datetime import datetime, timezone\nimport json\nimport os\n\napp = Flask(__name__)\nCORS(app)\n\nSTATS_FILE = 'bot_stats.json'\n\ndef get_bot_stats():\n    \"\"\"Load stats from file\"\"\"\n    try:\n        if os.path.exists(STATS_FILE):\n            with open(STATS_FILE, 'r') as f:\n                stats = json.load(f)\n                stats['start_time'] = datetime.fromisoformat(stats['start_time'])\n                return stats\n    except:\n        pass\n    \n    # Default stats if file doesn't exist\n    return {\n        'start_time': datetime.now(timezone.utc),\n        'guilds': 0,\n        'users': 0,\n        'channels': 0,\n        'status': 'initializing'\n    }\n\n@app.route('/')\ndef index():\n    \"\"\"Redirect root path to dashboard\"\"\"\n    return redirect('/dashboard', code=302)\n\n@app.route('/dashboard')\ndef dashboard():\n    stats = get_bot_stats()\n    uptime = datetime.now(timezone.utc) - stats['start_time']\n    hours, remainder = divmod(int(uptime.total_seconds()), 3600)\n    minutes, seconds = divmod(remainder, 60)\n    days, hours = divmod(hours, 24)\n    \n    uptime_str = f\"{days}d {hours}h {minutes}m {seconds}s\"\n    \n    response = app.make_response(render_template('index.html', \n                         guilds=stats['guilds'],\n                         users=stats['users'],\n                         channels=stats['channels'],\n                         uptime=uptime_str,\n                         status=stats['status']))\n    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n    response.headers['Pragma'] = 'no-cache'\n    response.headers['Expires'] = '0'\n    return response\n\n@app.route('/help')\ndef help_page():\n    \"\"\"Display bot commands and help information\"\"\"\n    response = app.make_response(render_template('help.html'))\n    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n    response.headers['Pragma'] = 'no-cache'\n    response.headers['Expires'] = '0'\n    return response\n\n@app.route('/api/stats')\ndef api_stats():\n    try:\n        stats = get_bot_stats()\n        uptime = datetime.now(timezone.utc) - stats['start_time']\n        \n        return jsonify({\n            'guilds': stats.get('guilds', 0),\n            'users': stats.get('users', 0),\n            'channels': stats.get('channels', 0),\n            'uptime_seconds': int(uptime.total_seconds()),\n            'status': stats.get('status', 'online')\n        })\n    except Exception as e:\n        return jsonify({\n            'guilds': 0,\n            'users': 0,\n            'channels': 0,\n            'uptime_seconds': 0,\n            'status': 'initializing',\n            'error': str(e)\n        }), 500\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=False)\n","size_bytes":2799},"cogs/music.py":{"content":"import discord\nfrom discord.ext import commands\nimport wavelink\nimport spotipy\nfrom spotipy.oauth2 import SpotifyClientCredentials\nimport os\nimport re\nimport asyncio\n\nclass Music(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        \n        spotify_id = os.getenv('SPOTIFY_CLIENT_ID')\n        spotify_secret = os.getenv('SPOTIFY_CLIENT_SECRET')\n        \n        if spotify_id and spotify_secret:\n            try:\n                self.spotify = spotipy.Spotify(auth_manager=SpotifyClientCredentials(\n                    client_id=spotify_id,\n                    client_secret=spotify_secret\n                ))\n            except:\n                self.spotify = None\n        else:\n            self.spotify = None\n    \n    async def cog_load(self):\n        \"\"\"Connect to Lavalink nodes when cog loads\"\"\"\n        nodes = [\n            wavelink.Node(\n                uri='https://lava-v4.ajieblogs.eu.org:443',\n                password='https://dsc.gg/ajidevserver'\n            ),\n            wavelink.Node(\n                uri='http://lava-us.catfein.co.id:5000',\n                password='catfein'\n            ),\n            wavelink.Node(\n                uri='http://lavalink.divahost.net:60002',\n                password='divahostv4'\n            ),\n            wavelink.Node(\n                uri='https://lavalink-v2.pericsq.ro:443',\n                password='wwweasycodero'\n            ),\n            wavelink.Node(\n                uri='http://publicnode.nextgencoders.xyz:2336',\n                password='nextgencoders'\n            )\n        ]\n        \n        try:\n            await asyncio.wait_for(\n                wavelink.Pool.connect(client=self.bot, nodes=nodes),\n                timeout=15.0\n            )\n            print(f\"âœ… Connected to Lavalink pool with {len(nodes)} nodes\")\n        except asyncio.TimeoutError:\n            print(\"âš ï¸ Lavalink connection timed out\")\n            print(\"âš ï¸ Music features will be unavailable\")\n        except Exception as e:\n            print(f\"âš ï¸ Failed to connect to Lavalink nodes: {e}\")\n            print(\"âš ï¸ Music features will be unavailable\")\n    \n    @commands.Cog.listener()\n    async def on_wavelink_track_end(self, payload: wavelink.TrackEndEventPayload):\n        \"\"\"Auto-play next track when current track finishes naturally\"\"\"\n        player = payload.player\n        if not player:\n            return\n        \n        if payload.reason is not wavelink.TrackEndReason.FINISHED:\n            return\n        \n        if player.current:\n            return\n        \n        if player.queue:\n            next_track = await player.queue.get_wait()\n            await player.play(next_track)\n    \n    def parse_spotify_url(self, url):\n        \"\"\"Extract Spotify track ID from URL\"\"\"\n        spotify_regex = r'https?://open\\.spotify\\.com/track/([a-zA-Z0-9]+)'\n        match = re.search(spotify_regex, url)\n        return match.group(1) if match else None\n    \n    async def search_spotify_track(self, track_id):\n        \"\"\"Get track info from Spotify and search on YouTube\"\"\"\n        if not self.spotify:\n            return None\n        \n        try:\n            track = self.spotify.track(track_id)\n            artists = ', '.join([artist['name'] for artist in track['artists']])\n            query = f\"{artists} - {track['name']}\"\n            return query\n        except:\n            return None\n    \n    @commands.command(name='play')\n    async def play(self, ctx, *, query: str):\n        \"\"\"Play music from YouTube, Spotify, or search query\"\"\"\n        if not ctx.author.voice:\n            embed = discord.Embed(\n                title=\"âŒ Not in Voice Channel\",\n                description=\"You need to be in a voice channel to play music!\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        voice_channel = ctx.author.voice.channel\n        \n        if not ctx.voice_client:\n            try:\n                vc: wavelink.Player = await voice_channel.connect(cls=wavelink.Player)\n            except Exception as e:\n                embed = discord.Embed(\n                    title=\"âŒ Connection Error\",\n                    description=f\"Failed to connect: {str(e)}\",\n                    color=0xFF006E\n                )\n                await ctx.send(embed=embed)\n                return\n        else:\n            vc: wavelink.Player = ctx.voice_client\n        \n        spotify_id = self.parse_spotify_url(query)\n        if spotify_id:\n            spotify_query = await self.search_spotify_track(spotify_id)\n            if spotify_query:\n                query = spotify_query\n        \n        try:\n            tracks: wavelink.Search = await wavelink.Playable.search(query)\n            if not tracks:\n                embed = discord.Embed(\n                    title=\"âŒ No Results\",\n                    description=\"No tracks found matching your query.\",\n                    color=0xFF006E\n                )\n                await ctx.send(embed=embed)\n                return\n            \n            track = tracks[0] if isinstance(tracks, list) else tracks\n            \n            if vc.playing:\n                await vc.queue.put_wait(track)\n                embed = discord.Embed(\n                    title=\"â• Added to Queue\",\n                    description=f\"**{track.title}**\\n`Position: {vc.queue.count}`\",\n                    color=0x8B00FF\n                )\n                if hasattr(track, 'artwork') and track.artwork:\n                    embed.set_thumbnail(url=track.artwork)\n            else:\n                await vc.play(track)\n                embed = discord.Embed(\n                    title=\"ğŸµ Now Playing\",\n                    description=f\"**{track.title}**\\n`{track.author}`\",\n                    color=0x00F3FF\n                )\n                if hasattr(track, 'artwork') and track.artwork:\n                    embed.set_thumbnail(url=track.artwork)\n            \n            await ctx.send(embed=embed)\n            \n        except Exception as e:\n            embed = discord.Embed(\n                title=\"âŒ Playback Error\",\n                description=f\"An error occurred: {str(e)}\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n    \n    @commands.command(name='pause')\n    async def pause(self, ctx):\n        \"\"\"Pause the current playback\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc or not vc.playing:\n            embed = discord.Embed(\n                title=\"âŒ Nothing Playing\",\n                description=\"There's nothing playing right now.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        await vc.pause(True)\n        embed = discord.Embed(\n            title=\"â¸ï¸ Paused\",\n            description=\"Playback has been paused.\",\n            color=0x8B00FF\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='resume')\n    async def resume(self, ctx):\n        \"\"\"Resume paused playback\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc or not vc.paused:\n            embed = discord.Embed(\n                title=\"âŒ Nothing Paused\",\n                description=\"There's nothing paused right now.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        await vc.pause(False)\n        embed = discord.Embed(\n            title=\"â–¶ï¸ Resumed\",\n            description=\"Playback has been resumed.\",\n            color=0x00F3FF\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='skip')\n    async def skip(self, ctx):\n        \"\"\"Skip to the next song\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc or not vc.playing:\n            embed = discord.Embed(\n                title=\"âŒ Nothing Playing\",\n                description=\"There's nothing playing right now.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        await vc.skip(force=True)\n        embed = discord.Embed(\n            title=\"â­ï¸ Skipped\",\n            description=\"Skipped to the next track.\",\n            color=0x8B00FF\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='stop')\n    async def stop(self, ctx):\n        \"\"\"Stop playback and disconnect\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc:\n            embed = discord.Embed(\n                title=\"âŒ Not Connected\",\n                description=\"I'm not connected to a voice channel.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        await vc.disconnect()\n        embed = discord.Embed(\n            title=\"â¹ï¸ Stopped\",\n            description=\"Playback stopped and disconnected.\",\n            color=0xFF006E\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='queue')\n    async def queue(self, ctx):\n        \"\"\"Display the music queue\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc:\n            embed = discord.Embed(\n                title=\"âŒ Not Connected\",\n                description=\"I'm not connected to a voice channel.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        embed = discord.Embed(\n            title=\"ğŸµ Music Queue\",\n            color=0x8B00FF\n        )\n        \n        if vc.current:\n            embed.add_field(\n                name=\"Now Playing\",\n                value=f\"ğŸ¶ **{vc.current.title}**\\n`{vc.current.author}`\",\n                inline=False\n            )\n        \n        if vc.queue:\n            queue_list = []\n            for i, track in enumerate(vc.queue[:10], 1):\n                queue_list.append(f\"{i}. **{track.title}** - `{track.author}`\")\n            \n            embed.add_field(\n                name=f\"Up Next ({vc.queue.count} songs)\",\n                value=\"\\n\".join(queue_list),\n                inline=False\n            )\n        else:\n            if not vc.current:\n                embed.description = \"Queue is empty\"\n        \n        if vc.queue.mode == wavelink.QueueMode.loop:\n            embed.set_footer(text=\"ğŸ” Loop: ON\")\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='nowplaying', aliases=['np'])\n    async def nowplaying(self, ctx):\n        \"\"\"Show currently playing track\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc or not vc.current:\n            embed = discord.Embed(\n                title=\"âŒ Nothing Playing\",\n                description=\"There's nothing playing right now.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        track = vc.current\n        \n        position = vc.position\n        duration = track.length\n        \n        progress_bar_length = 20\n        progress = int((position / duration) * progress_bar_length)\n        bar = \"â–ˆ\" * progress + \"â–‘\" * (progress_bar_length - progress)\n        \n        position_str = f\"{int(position // 60)}:{int(position % 60):02d}\"\n        duration_str = f\"{int(duration // 60)}:{int(duration % 60):02d}\"\n        \n        embed = discord.Embed(\n            title=\"ğŸµ Now Playing\",\n            description=f\"**{track.title}**\\n`{track.author}`\",\n            color=0x00F3FF\n        )\n        \n        embed.add_field(\n            name=\"Progress\",\n            value=f\"`{position_str}` {bar} `{duration_str}`\",\n            inline=False\n        )\n        \n        if hasattr(track, 'artwork') and track.artwork:\n            embed.set_thumbnail(url=track.artwork)\n        \n        if vc.queue.mode == wavelink.QueueMode.loop:\n            embed.set_footer(text=\"ğŸ” Loop: ON\")\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='loop')\n    async def loop(self, ctx):\n        \"\"\"Toggle loop mode\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc:\n            embed = discord.Embed(\n                title=\"âŒ Not Connected\",\n                description=\"I'm not connected to a voice channel.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if vc.queue.mode == wavelink.QueueMode.loop:\n            vc.queue.mode = wavelink.QueueMode.normal\n            status = \"disabled\"\n            emoji = \"â¡ï¸\"\n        else:\n            vc.queue.mode = wavelink.QueueMode.loop\n            status = \"enabled\"\n            emoji = \"ğŸ”\"\n        \n        embed = discord.Embed(\n            title=f\"{emoji} Loop Mode\",\n            description=f\"Loop mode has been **{status}**.\",\n            color=0x8B00FF\n        )\n        await ctx.send(embed=embed)\n    \n    @commands.command(name='volume')\n    async def volume(self, ctx, volume: int):\n        \"\"\"Adjust playback volume (0-100)\"\"\"\n        vc: wavelink.Player = ctx.voice_client\n        \n        if not vc:\n            embed = discord.Embed(\n                title=\"âŒ Not Connected\",\n                description=\"I'm not connected to a voice channel.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        if volume < 0 or volume > 100:\n            embed = discord.Embed(\n                title=\"âŒ Invalid Volume\",\n                description=\"Volume must be between 0 and 100.\",\n                color=0xFF006E\n            )\n            await ctx.send(embed=embed)\n            return\n        \n        await vc.set_volume(volume)\n        embed = discord.Embed(\n            title=\"ğŸ”Š Volume Adjusted\",\n            description=f\"Volume set to **{volume}%**\",\n            color=0x00F3FF\n        )\n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(Music(bot))\n","size_bytes":13958},"cogs/admin.py":{"content":"import discord\nfrom discord.ext import commands\nfrom datetime import datetime, timezone\nfrom translations import get_text\n\nclass Admin(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    \n    @commands.Cog.listener()\n    async def on_guild_join(self, guild):\n        app_info = await self.bot.application_info()\n        owner = app_info.owner\n        \n        embed = discord.Embed(\n            title=\"ğŸ‰ Bot Invited to New Server!\",\n            description=f\"I've been added to **{guild.name}**\",\n            color=0x00ffff,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.add_field(\n            name=\"ğŸ“Š Server Info\",\n            value=f\"**Name:** {guild.name}\\n**ID:** `{guild.id}`\\n**Members:** {guild.member_count}\",\n            inline=False\n        )\n        \n        if guild.owner:\n            embed.add_field(\n                name=\"ğŸ‘‘ Server Owner\",\n                value=f\"{guild.owner.mention} ({guild.owner})\\n**ID:** `{guild.owner.id}`\",\n                inline=False\n            )\n        \n        embed.add_field(\n            name=\"ğŸ“… Server Created\",\n            value=f\"{guild.created_at.strftime('%Y-%m-%d')}\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸŒ Total Servers\",\n            value=f\"{len(self.bot.guilds)} servers\",\n            inline=True\n        )\n        \n        if guild.icon:\n            embed.set_thumbnail(url=guild.icon.url)\n        \n        embed.set_footer(text=f\"Server ID: {guild.id}\")\n        \n        try:\n            await owner.send(embed=embed)\n        except:\n            pass\n    \n    def is_bot_owner():\n        async def predicate(ctx):\n            return await ctx.bot.is_owner(ctx.author)\n        return commands.check(predicate)\n    \n    @commands.command(name='servers')\n    @is_bot_owner()\n    async def servers(self, ctx):\n        guild_id = ctx.guild.id if ctx.guild else None\n        \n        embed = discord.Embed(\n            title=get_text(guild_id, 'servers_title'),\n            description=get_text(guild_id, 'servers_description', len(self.bot.guilds)),\n            color=0x00ffff\n        )\n        \n        server_list = []\n        for guild in self.bot.guilds:\n            server_list.append(f\"**{guild.name}**\\n`ID: {guild.id}`\")\n        \n        if server_list:\n            chunks = [server_list[i:i+10] for i in range(0, len(server_list), 10)]\n            for i, chunk in enumerate(chunks):\n                embed.add_field(\n                    name=f\"Servers {i*10 + 1}-{min((i+1)*10, len(server_list))}\",\n                    value=\"\\n\\n\".join(chunk),\n                    inline=False\n                )\n        \n        embed.set_footer(text=get_text(guild_id, 'servers_footer', len(self.bot.guilds)))\n        if self.bot.user.avatar:\n            embed.set_thumbnail(url=self.bot.user.avatar.url)\n        \n        await ctx.send(embed=embed)\n    \n    @servers.error\n    async def servers_error(self, ctx, error):\n        if isinstance(error, commands.CheckFailure):\n            guild_id = ctx.guild.id if ctx.guild else None\n            await ctx.send(get_text(guild_id, 'owner_only'))\n    \n    @commands.command(name='createinvite')\n    @is_bot_owner()\n    async def create_invite(self, ctx, server_id: int):\n        guild_id = ctx.guild.id if ctx.guild else None\n        \n        guild = self.bot.get_guild(server_id)\n        \n        if guild is None:\n            await ctx.send(get_text(guild_id, 'server_not_found'))\n            return\n        \n        text_channels = [ch for ch in guild.text_channels if ch.permissions_for(guild.me).create_instant_invite]\n        \n        if not text_channels:\n            await ctx.send(get_text(guild_id, 'no_permission_invite', guild.name))\n            return\n        \n        channel = text_channels[0]\n        \n        try:\n            invite = await channel.create_invite(max_age=0, max_uses=0, reason=f\"Created by bot owner {ctx.author}\")\n            \n            embed = discord.Embed(\n                title=get_text(guild_id, 'invite_created'),\n                description=get_text(guild_id, 'invite_created_desc', guild.name),\n                color=0x00ffff\n            )\n            embed.add_field(name=get_text(guild_id, 'invite_link'), value=invite.url, inline=False)\n            embed.add_field(name=get_text(guild_id, 'invite_expires'), value=get_text(guild_id, 'invite_never'), inline=True)\n            if guild.icon:\n                embed.set_thumbnail(url=guild.icon.url)\n            \n            await ctx.send(embed=embed)\n        \n        except discord.Forbidden:\n            await ctx.send(get_text(guild_id, 'no_permission_invite', guild.name))\n        except Exception as e:\n            await ctx.send(f\"âŒ Error creating invite: {e}\")\n    \n    @create_invite.error\n    async def create_invite_error(self, ctx, error):\n        if isinstance(error, commands.CheckFailure):\n            guild_id = ctx.guild.id if ctx.guild else None\n            await ctx.send(get_text(guild_id, 'owner_only'))\n\nasync def setup(bot):\n    await bot.add_cog(Admin(bot))\n","size_bytes":5091},"cogs/info.py":{"content":"import discord\nfrom discord.ext import commands\nfrom datetime import datetime, timezone\nimport platform\nimport os\n\nclass Info(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        # Use custom domain shadowmod.net\n        self.custom_domain = 'https://shadowmod.net'\n        # Add /dashboard path to URL\n        self.dashboard_url = f'{self.custom_domain}/dashboard'\n    \n    @commands.command(name='serverinfo', aliases=['si'])\n    async def serverinfo(self, ctx):\n        \"\"\"Show server information\"\"\"\n        guild = ctx.guild\n        \n        # Count channels by type\n        text_channels = len(guild.text_channels)\n        voice_channels = len(guild.voice_channels)\n        categories = len(guild.categories)\n        \n        # Get boost info\n        boost_level = guild.premium_tier\n        boost_count = guild.premium_subscription_count\n        \n        # Get role count (excluding @everyone)\n        role_count = len(guild.roles) - 1\n        \n        # Create embed\n        embed = discord.Embed(\n            title=f\"âš¡ {guild.name} Server Info\",\n            description=f\"**ID:** `{guild.id}`\",\n            color=0x00F3FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        if guild.icon:\n            embed.set_thumbnail(url=guild.icon.url)\n        \n        # Server Stats\n        embed.add_field(\n            name=\"ğŸ‘‘ Owner\",\n            value=f\"{guild.owner.mention}\\n`{guild.owner}`\",\n            inline=True\n        )\n        embed.add_field(\n            name=\"ğŸ“… Created\",\n            value=f\"<t:{int(guild.created_at.timestamp())}:R>\",\n            inline=True\n        )\n        embed.add_field(\n            name=\"ğŸŒŸ Boost Level\",\n            value=f\"Level {boost_level}\\n{boost_count} boosts\",\n            inline=True\n        )\n        \n        # Member Stats\n        embed.add_field(\n            name=\"ğŸ‘¥ Members\",\n            value=f\"**Total:** {guild.member_count}\\n**Humans:** {len([m for m in guild.members if not m.bot])}\\n**Bots:** {len([m for m in guild.members if m.bot])}\",\n            inline=True\n        )\n        \n        # Channel Stats\n        embed.add_field(\n            name=\"ğŸ’¬ Channels ({})\".format(text_channels + voice_channels),\n            value=f\"**Text:** {text_channels}\\n**Voice:** {voice_channels}\\n**Categories:** {categories}\",\n            inline=True\n        )\n        \n        # Role Stats\n        embed.add_field(\n            name=\"ğŸ­ Roles\",\n            value=f\"{role_count} roles\",\n            inline=True\n        )\n        \n        # Verification level\n        verification = str(guild.verification_level).replace('_', ' ').title()\n        embed.add_field(\n            name=\"ğŸ”’ Security\",\n            value=f\"**Verification:** {verification}\\n**2FA Required:** {'Yes' if guild.mfa_level else 'No'}\",\n            inline=True\n        )\n        \n        # Features\n        features = []\n        if \"COMMUNITY\" in guild.features:\n            features.append(\"âœ… Community\")\n        if \"VERIFIED\" in guild.features:\n            features.append(\"âœ… Verified\")\n        if \"PARTNERED\" in guild.features:\n            features.append(\"âœ… Partnered\")\n        if \"DISCOVERABLE\" in guild.features:\n            features.append(\"âœ… Discoverable\")\n        \n        if features:\n            embed.add_field(\n                name=\"âœ¨ Features\",\n                value=\"\\n\".join(features),\n                inline=True\n            )\n        \n        if guild.banner:\n            embed.set_image(url=guild.banner.url)\n        \n        embed.set_footer(text=f\"Requested by {ctx.author}\", icon_url=ctx.author.display_avatar.url)\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='botinfo', aliases=['bi'])\n    async def botinfo(self, ctx):\n        \"\"\"Show bot information and statistics\"\"\"\n        # Calculate uptime\n        uptime = datetime.now(timezone.utc) - self.bot.start_time\n        hours, remainder = divmod(int(uptime.total_seconds()), 3600)\n        minutes, seconds = divmod(remainder, 60)\n        days, hours = divmod(hours, 24)\n        \n        uptime_str = f\"{days}d {hours}h {minutes}m {seconds}s\"\n        \n        # Calculate stats\n        total_members = sum(guild.member_count for guild in self.bot.guilds)\n        total_channels = sum(len(guild.channels) for guild in self.bot.guilds)\n        \n        embed = discord.Embed(\n            title=\"âš¡ SHADOW-MOD âœ¨ | Bot Info\",\n            description=\"**Made by MoonlightVFX**\\nFuturistic bot with AI integration & real-time web dashboard\",\n            color=0x8B00FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        embed.set_thumbnail(url=self.bot.user.display_avatar.url)\n        \n        # Bot Stats\n        embed.add_field(\n            name=\"ğŸ“Š Statistics\",\n            value=f\"**Servers:** {len(self.bot.guilds)}\\n**Users:** {total_members:,}\\n**Channels:** {total_channels:,}\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"â±ï¸ Uptime\",\n            value=uptime_str,\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ Python Version\",\n            value=platform.python_version(),\n            inline=True\n        )\n        \n        # Features\n        features = [\n            \"âœ… Dual Prefix (!  and /)\",\n            \"âœ… 20+ Slash Commands\",\n            \"âœ… Multilingual (EN/HU)\",\n            \"âœ… AI Chat Assistant\",\n            \"âœ… Ticket System\",\n            \"âœ… Anti-Alt Detection\",\n            \"âœ… Advanced Moderation\",\n            \"âœ… Interactive Games\",\n            \"âœ… Poll & Giveaway System\",\n            \"âœ… Role Management\",\n            \"âœ… Webhook Logging\",\n            \"âœ… Member Verification\",\n            \"âœ… Live Web Dashboard\"\n        ]\n        \n        embed.add_field(\n            name=\"âœ¨ Features\",\n            value=\"\\n\".join(features[:7]),\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸš€ More Features\",\n            value=\"\\n\".join(features[7:]),\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"ğŸ”— Links\",\n            value=f\"[ğŸ“– Command List]({self.custom_domain}/help)\\n[ğŸ“Š Web Dashboard]({self.dashboard_url})\\n[ğŸ’¬ Support Server](https://discord.gg/w6s6qA4E7E)\\n[â• Add Bot](https://discord.com/api/oauth2/authorize?client_id={self.bot.user.id}&permissions=8&scope=bot%20applications.commands)\",\n            inline=True\n        )\n        \n        embed.set_footer(text=f\"Requested by {ctx.author}\", icon_url=ctx.author.display_avatar.url)\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='userinfo', aliases=['ui', 'whois'])\n    async def userinfo(self, ctx, member: discord.Member = None):\n        \"\"\"Show detailed user information with badges\"\"\"\n        member = member or ctx.author\n        \n        # Create embed\n        embed = discord.Embed(\n            title=f\"âš¡ User Information\",\n            color=0x00F3FF,\n            timestamp=datetime.now(timezone.utc)\n        )\n        \n        # Set user avatar as main image (top)\n        embed.set_author(name=str(member), icon_url=member.display_avatar.url)\n        embed.set_thumbnail(url=member.display_avatar.url)\n        \n        # Basic Info\n        embed.add_field(\n            name=\"ğŸ‘¤ User Info\",\n            value=f\"**Username:** {member.name}\\n**Display Name:** {member.display_name}\\n**ID:** `{member.id}`\\n**Bot:** {'Yes âœ…' if member.bot else 'No âŒ'}\",\n            inline=True\n        )\n        \n        # Account Creation\n        account_age = datetime.now(timezone.utc) - member.created_at\n        embed.add_field(\n            name=\"ğŸ“… Account Created\",\n            value=f\"<t:{int(member.created_at.timestamp())}:F>\\n({account_age.days} days ago)\",\n            inline=True\n        )\n        \n        # Join Date\n        if member.joined_at:\n            join_age = datetime.now(timezone.utc) - member.joined_at\n            embed.add_field(\n                name=\"ğŸ“¥ Joined Server\",\n                value=f\"<t:{int(member.joined_at.timestamp())}:F>\\n({join_age.days} days ago)\",\n                inline=True\n            )\n        \n        # Badges\n        badges = []\n        flags = member.public_flags\n        \n        if flags.staff:\n            badges.append(\"<:staff:> Discord Staff\")\n        if flags.partner:\n            badges.append(\"<:partner:> Partnered Server Owner\")\n        if flags.hypesquad:\n            badges.append(\"<:hypesquad:> HypeSquad Events\")\n        if flags.hypesquad_balance:\n            badges.append(\"âš–ï¸ HypeSquad Balance\")\n        if flags.hypesquad_bravery:\n            badges.append(\"ğŸ›¡ï¸ HypeSquad Bravery\")\n        if flags.hypesquad_brilliance:\n            badges.append(\"ğŸ’ HypeSquad Brilliance\")\n        if flags.bug_hunter:\n            badges.append(\"ğŸ› Bug Hunter\")\n        if flags.bug_hunter_level_2:\n            badges.append(\"ğŸ› Bug Hunter Level 2\")\n        if flags.verified_bot_developer:\n            badges.append(\"âš™ï¸ Early Verified Bot Developer\")\n        if flags.early_supporter:\n            badges.append(\"ğŸ’– Early Supporter\")\n        if flags.active_developer:\n            badges.append(\"ğŸ”§ Active Developer\")\n        if member.premium_since:\n            badges.append(f\"ğŸ’ Server Booster (since <t:{int(member.premium_since.timestamp())}:R>)\")\n        \n        if badges:\n            embed.add_field(\n                name=\"ğŸ… Badges\",\n                value=\"\\n\".join(badges),\n                inline=False\n            )\n        \n        # Roles\n        if len(member.roles) > 1:  # Exclude @everyone\n            roles = [role.mention for role in reversed(member.roles[1:])]  # Skip @everyone\n            roles_text = \", \".join(roles[:10])  # Show first 10 roles\n            if len(member.roles) > 11:\n                roles_text += f\" ... and {len(member.roles) - 11} more\"\n            \n            embed.add_field(\n                name=f\"ğŸ­ Roles ({len(member.roles) - 1})\",\n                value=roles_text,\n                inline=False\n            )\n        \n        # Key Permissions\n        perms = []\n        if member.guild_permissions.administrator:\n            perms.append(\"ğŸ‘‘ Administrator\")\n        if member.guild_permissions.manage_guild:\n            perms.append(\"âš™ï¸ Manage Server\")\n        if member.guild_permissions.manage_channels:\n            perms.append(\"ğŸ“ Manage Channels\")\n        if member.guild_permissions.manage_roles:\n            perms.append(\"ğŸ­ Manage Roles\")\n        if member.guild_permissions.ban_members:\n            perms.append(\"ğŸ”¨ Ban Members\")\n        if member.guild_permissions.kick_members:\n            perms.append(\"ğŸ‘¢ Kick Members\")\n        \n        if perms:\n            embed.add_field(\n                name=\"ğŸ”‘ Key Permissions\",\n                value=\"\\n\".join(perms),\n                inline=False\n            )\n        \n        # Status\n        status_emoji = {\n            discord.Status.online: \"ğŸŸ¢ Online\",\n            discord.Status.idle: \"ğŸŸ¡ Idle\",\n            discord.Status.dnd: \"ğŸ”´ Do Not Disturb\",\n            discord.Status.offline: \"âš« Offline\"\n        }\n        \n        embed.add_field(\n            name=\"ğŸ“± Status\",\n            value=status_emoji.get(member.status, \"âš« Unknown\"),\n            inline=True\n        )\n        \n        # Top role color\n        if member.top_role.color.value != 0:\n            embed.color = member.top_role.color\n        \n        embed.set_footer(text=f\"Requested by {ctx.author}\", icon_url=ctx.author.display_avatar.url)\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='support')\n    async def support(self, ctx):\n        \"\"\"Get the support server invite link\"\"\"\n        embed = discord.Embed(\n            title=\"ğŸ’¬ Support Server\",\n            description=\"Join our support server for help, updates, and more!\",\n            color=0x8B00FF\n        )\n        \n        embed.add_field(\n            name=\"ğŸ”— Invite Link\",\n            value=\"[Click here to join!](https://discord.gg/w6s6qA4E7E)\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"âœ¨ What you'll find:\",\n            value=\"â€¢ Get help with bot commands\\nâ€¢ Report bugs and issues\\nâ€¢ Suggest new features\\nâ€¢ Get updates and announcements\\nâ€¢ Chat with other users\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"We'd love to see you there! ğŸ’œ\")\n        \n        await ctx.send(embed=embed)\n    \n    @commands.command(name='webpage', aliases=['web', 'dashboard'])\n    async def webpage(self, ctx):\n        \"\"\"Get the link to the bot's live web dashboard\"\"\"\n        embed = discord.Embed(\n            title=\"ğŸŒ Live Web Dashboard\",\n            description=\"Check out the bot's real-time statistics on our futuristic web page!\",\n            color=0x00F3FF\n        )\n        \n        embed.add_field(\n            name=\"ğŸ”— Dashboard Link\",\n            value=f\"[Click here to view]({self.dashboard_url})\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"ğŸ“Š Features:\",\n            value=\"â€¢ Real-time bot statistics\\nâ€¢ Server, user & channel counts\\nâ€¢ Live uptime tracking\\nâ€¢ Futuristic cyberpunk theme\\nâ€¢ Auto-refreshing data\",\n            inline=False\n        )\n        \n        embed.set_footer(text=\"Dashboard updates every 5 seconds âš¡\")\n        \n        await ctx.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(Info(bot))\n","size_bytes":13503},"cogs/customcommands.py":{"content":"import discord\nfrom discord.ext import commands\nimport json\nimport os\n\nCONFIG_FILE = 'bot_config.json'\n\nclass CustomCommands(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.custom_commands = self.load_custom_commands()\n    \n    def load_custom_commands(self):\n        \"\"\"Load custom commands from config\"\"\"\n        if os.path.exists(CONFIG_FILE):\n            try:\n                with open(CONFIG_FILE, 'r') as f:\n                    config = json.load(f)\n                    return config.get('custom_commands', {})\n            except:\n                return {}\n        return {}\n    \n    def save_custom_commands(self):\n        \"\"\"Save custom commands to config\"\"\"\n        config = {}\n        if os.path.exists(CONFIG_FILE):\n            try:\n                with open(CONFIG_FILE, 'r') as f:\n                    config = json.load(f)\n            except:\n                pass\n        \n        config['custom_commands'] = self.custom_commands\n        \n        with open(CONFIG_FILE, 'w') as f:\n            json.dump(config, f, indent=4)\n    \n    @commands.Cog.listener()\n    async def on_message(self, message):\n        \"\"\"Listen for custom command triggers\"\"\"\n        if message.author.bot:\n            return\n        \n        # Check if message starts with any guild prefix or default\n        if not message.guild:\n            return\n        \n        # Import config to get guild prefix\n        import config\n        prefix = config.get_guild_prefix(message.guild.id)\n        \n        if not message.content.startswith(prefix):\n            return\n        \n        # Extract command name (remove prefix)\n        content_after_prefix = message.content[len(prefix):].split()\n        \n        # If user just sent the prefix without any command, ignore\n        if not content_after_prefix:\n            return\n        \n        command_name = content_after_prefix[0].lower()\n        \n        # Check if it's a custom command\n        if command_name in self.custom_commands:\n            response = self.custom_commands[command_name]\n            \n            embed = discord.Embed(\n                description=response,\n                color=0x00F3FF\n            )\n            embed.set_footer(text=f\"Custom Command: {command_name}\")\n            \n            await message.channel.send(embed=embed)\n\nasync def setup(bot):\n    await bot.add_cog(CustomCommands(bot))\n","size_bytes":2390}},"version":2}